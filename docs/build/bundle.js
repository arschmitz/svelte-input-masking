(()=>{"use strict";var __webpack_modules__={815:()=>{eval('\n// UNUSED EXPORTS: default\n\n;// CONCATENATED MODULE: ./node_modules/svelte/internal/index.mjs\nfunction noop() { }\nconst identity = x => x;\nfunction internal_assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === \'object\' && typeof value.then === \'function\';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === \'function\';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === \'object\') || typeof a === \'function\');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement(\'a\');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== \'function\') {\n        throw new Error(`\'${name}\' is not a store with a \'subscribe\' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? internal_assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === \'object\') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== \'$\')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== \'$\')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? \'\' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== \'undefined\';\nlet now = (/* unused pure expression or super */ null && (is_client\n    ? () => window.performance.now()\n    : () => Date.now()));\nlet raf = (/* unused pure expression or super */ null && (is_client ? cb => requestAnimationFrame(cb) : noop));\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === \'HEAD\') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = internal_element(\'style\');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = internal_element(\'style\');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction internal_element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS(\'http://www.w3.org/2000/svg\', name);\n}\nfunction internal_text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return internal_text(\' \');\n}\nfunction empty() {\n    return internal_text(\'\');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction internal_self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === \'style\') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === \'__value\') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === \'boolean\' && value === \'\' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS(\'http://www.w3.org/1999/xlink\', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === \'\' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don\'t go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can\'t find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, internal_element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = \'\' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => internal_text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, \' \');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, \'HTML_TAG_START\', 0);\n    const end_index = find_comment(nodes, \'HTML_TAG_END\', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = \'\' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? \'\' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? \'important\' : \'\');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(\':checked\') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(\':checked\'), option => option.__value);\n}\n// unfortunately this can\'t be a constant as that wouldn\'t be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== \'undefined\' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === \'static\') {\n        node.style.position = \'relative\';\n    }\n    const iframe = internal_element(\'iframe\');\n    iframe.setAttribute(\'style\', \'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \' +\n        \'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;\');\n    iframe.setAttribute(\'aria-hidden\', \'true\');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,\'*\')}<\/script>";\n        unsubscribe = listen(window, \'message\', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = \'about:blank\';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, \'resize\', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? \'add\' : \'remove\'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent(\'CustomEvent\');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = internal_element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends (/* unused pure expression or super */ null && (HtmlTag)) {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || \'default\'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = \'{\\n\';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || \'\';\n    node.style.animation = `${animation ? `${animation}, ` : \'\'}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || \'\').split(\', \');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf(\'__svelte\') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(\', \');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== \'absolute\' && style.position !== \'fixed\') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = \'absolute\';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === \'none\' ? \'\' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(\'Function called outside component initialization\');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the "parent" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? \'intro\' : \'outro\'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, \'start\'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, \'end\');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, \'start\'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, \'end\');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don\'t need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there\'s a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, \'start\'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, \'start\');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, \'end\');\n                        if (!pending_program) {\n                            // we\'re done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== \'undefined\'\n    ? window\n    : typeof globalThis !== \'undefined\'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(\'Cannot have duplicate keys in a keyed each\');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === \'object\' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    \'allowfullscreen\',\n    \'allowpaymentrequest\',\n    \'async\',\n    \'autofocus\',\n    \'autoplay\',\n    \'checked\',\n    \'controls\',\n    \'default\',\n    \'defer\',\n    \'disabled\',\n    \'formnovalidate\',\n    \'hidden\',\n    \'ismap\',\n    \'loop\',\n    \'multiple\',\n    \'muted\',\n    \'nomodule\',\n    \'novalidate\',\n    \'open\',\n    \'playsinline\',\n    \'readonly\',\n    \'required\',\n    \'reversed\',\n    \'selected\'\n]);\n\nconst invalid_attribute_name_character = /[\\s\'">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += \' \' + classes_to_add;\n        }\n    }\n    let str = \'\';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \' \' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \' \' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}="${value}"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    \'"\': \'&quot;\',\n    "\'": \'&#39;\',\n    \'&\': \'&amp;\',\n    \'<\': \'&lt;\',\n    \'>\': \'&gt;\'\n};\nfunction internal_escape(html) {\n    return String(html).replace(/["\'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === \'string\' ? internal_escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = \'\';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => \'\'\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === \'svelte:component\')\n            name += \' this={...}\';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + \' \' : \'\'}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return \'\';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: \'\', head: \'\', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join(\'\\n\'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return \'\';\n    return ` ${name}${value === true ? \'\' : `=${typeof value === \'string\' ? JSON.stringify(internal_escape(value)) : `"${value}"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class="${classes}"` : \'\';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === \'function\') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: \'open\' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: \'3.44.3\' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\'SvelteDOMRemove\', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\'capture\'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push(\'preventDefault\');\n    if (has_stop_propagation)\n        modifiers.push(\'stopPropagation\');\n    dispatch_dev(\'SvelteDOMAddEventListener\', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\'SvelteDOMRemoveEventListener\', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\'SvelteDOMRemoveAttribute\', { node, attribute });\n    else\n        dispatch_dev(\'SvelteDOMSetAttribute\', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\'SvelteDOMSetProperty\', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\'SvelteDOMSetDataset\', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = \'\' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev(\'SvelteDOMSetData\', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== \'string\' && !(arg && typeof arg === \'object\' && \'length\' in arg)) {\n        let msg = \'{#each} only iterates over array-like objects.\';\n        if (typeof Symbol === \'function\' && arg && Symbol.iterator in arg) {\n            msg += \' You can use a spread to convert this iterable into an array.\';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends (/* unused pure expression or super */ null && (SvelteComponent)) {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error("\'target\' is a required option");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(\'Component was already destroyed\'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from "svelte";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang="ts">\n * \timport { MyComponent } from "component-library";\n * <\/script>\n * <MyComponent foo={\'bar\'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(\'Infinite loop detected\');\n        }\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./src/components/MaskedInput.svelte\n/* src/components/MaskedInput.svelte generated by Svelte v3.44.3 */\n\n\nfunction add_css(target) {\n\tappend_styles(target, "svelte-19ixuh6", ".svelte-19ixuh6.svelte-19ixuh6:invalid{outline:1px solid red}.shell.svelte-19ixuh6.svelte-19ixuh6{position:relative;line-height:1}.shell.svelte-19ixuh6 span.svelte-19ixuh6{position:absolute;top:50%;left:4px;transform:translateY(-50%);color:#ccc;pointer-events:none;z-index:-1}.shell.svelte-19ixuh6 span i.svelte-19ixuh6{font-style:normal;color:transparent;opacity:0;visibility:hidden}input.masked.svelte-19ixuh6.svelte-19ixuh6,.shell.svelte-19ixuh6 span.svelte-19ixuh6{font-size:16px;font-family:monospace;padding-right:10px;background-color:transparent;text-transform:uppercase}");\n}\n\nfunction create_fragment(ctx) {\n\tlet span1;\n\tlet span0;\n\tlet t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "";\n\tlet t0;\n\tlet i;\n\tlet t1;\n\tlet t2;\n\tlet t3;\n\tlet input;\n\tlet input_maxlength_value;\n\tlet mounted;\n\tlet dispose;\n\n\tlet input_levels = [\n\t\t{ class: "masked" },\n\t\t{ pattern: /*currentPattern*/ ctx[5] },\n\t\t{ value: /*rawValue*/ ctx[3] },\n\t\t{\n\t\t\tmaxlength: input_maxlength_value = /*placeholder*/ ctx[2].length\n\t\t},\n\t\t/*$$restProps*/ ctx[9]\n\t];\n\n\tlet input_data = {};\n\n\tfor (let i = 0; i < input_levels.length; i += 1) {\n\t\tinput_data = internal_assign(input_data, input_levels[i]);\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tspan1 = internal_element("span");\n\t\t\tspan0 = internal_element("span");\n\t\t\tt0 = internal_text(t0_value);\n\t\t\ti = internal_element("i");\n\t\t\tt1 = internal_text(/*hiddenValue*/ ctx[7]);\n\t\t\tt2 = internal_text(/*remainingMask*/ ctx[6]);\n\t\t\tt3 = space();\n\t\t\tinput = internal_element("input");\n\t\t\tattr(i, "class", "svelte-19ixuh6");\n\t\t\tattr(span0, "aria-hidden", "true");\n\t\t\tattr(span0, "class", "svelte-19ixuh6");\n\t\t\tset_attributes(input, input_data);\n\t\t\ttoggle_class(input, "svelte-19ixuh6", true);\n\t\t\tattr(span1, "class", "shell svelte-19ixuh6");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, span1, anchor);\n\t\t\tappend(span1, span0);\n\t\t\tappend(span0, t0);\n\t\t\tappend(span0, i);\n\t\t\tappend(i, t1);\n\t\t\tappend(span0, t2);\n\t\t\tappend(span1, t3);\n\t\t\tappend(span1, input);\n\t\t\tinput.value = input_data.value;\n\t\t\tif (input.autofocus) input.focus();\n\t\t\t/*input_binding*/ ctx[16](input);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = listen(input, "keyup", /*update*/ ctx[8]);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tif (dirty & /*value, prefix*/ 3 && t0_value !== (t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "")) set_data(t0, t0_value);\n\t\t\tif (dirty & /*hiddenValue*/ 128) set_data(t1, /*hiddenValue*/ ctx[7]);\n\t\t\tif (dirty & /*remainingMask*/ 64) set_data(t2, /*remainingMask*/ ctx[6]);\n\n\t\t\tset_attributes(input, input_data = get_spread_update(input_levels, [\n\t\t\t\t{ class: "masked" },\n\t\t\t\tdirty & /*currentPattern*/ 32 && { pattern: /*currentPattern*/ ctx[5] },\n\t\t\t\tdirty & /*rawValue*/ 8 && input.value !== /*rawValue*/ ctx[3] && { value: /*rawValue*/ ctx[3] },\n\t\t\t\tdirty & /*placeholder*/ 4 && input_maxlength_value !== (input_maxlength_value = /*placeholder*/ ctx[2].length) && { maxlength: input_maxlength_value },\n\t\t\t\tdirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]\n\t\t\t]));\n\n\t\t\tif (\'value\' in input_data) {\n\t\t\t\tinput.value = input_data.value;\n\t\t\t}\n\n\t\t\ttoggle_class(input, "svelte-19ixuh6", true);\n\t\t},\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(span1);\n\t\t\t/*input_binding*/ ctx[16](null);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet hiddenValue;\n\tlet usedPattern;\n\n\tconst omit_props_names = [\n\t\t"letter","number","placeholder","validExample","value","charset","pattern","prefix","required"\n\t];\n\n\tlet $$restProps = compute_rest_props($$props, omit_props_names);\n\tlet { letter = \'_\' } = $$props;\n\tlet { number = \'XdDmMyY9\' } = $$props;\n\tlet { placeholder = \'\' } = $$props;\n\tlet { validExample = \'\' } = $$props;\n\tlet { value = \'\' } = $$props;\n\tlet { charset = null } = $$props;\n\tlet { pattern = \'\' } = $$props;\n\tlet { prefix = \'\' } = $$props;\n\tlet { required = false } = $$props;\n\tlet rawValue = \'\';\n\tlet inputElement;\n\tlet currentPattern = null;\n\tlet remainingMask = placeholder;\n\n\tasync function update(event) {\n\t\tconst cursorPosBefore = inputElement.selectionStart;\n\t\tlet cursorPosAfter;\n\t\t$$invalidate(3, rawValue = inputElement.value);\n\n\t\t$$invalidate(0, value = charset\n\t\t? rawValue.replace(/\\W/g, \'\')\n\t\t: rawValue.replace(/[^\\d.-]/g, \'\'));\n\n\t\t$$invalidate(5, currentPattern = null);\n\t\tevent.preventDefault();\n\t\tcursorPosAfter = inputElement.selectionStart;\n\t\tupdateMask();\n\t\t$$invalidate(5, currentPattern = usedPattern);\n\n\t\tif (cursorPosAfter - cursorPosBefore > 1) {\n\t\t\t$$invalidate(4, inputElement.selectionStart = cursorPosBefore, inputElement);\n\t\t\t$$invalidate(4, inputElement.selectionEnd = cursorPosBefore, inputElement);\n\t\t}\n\t}\n\n\tfunction updateMask() {\n\t\tlet newValue = \'\';\n\t\tconst strippedValue = value.replace(/\\D/g, \'\');\n\n\t\tfor (let i = 0, j = 0; i < placeholder.length; i++) {\n\t\t\tconst isInt = !Number.isNaN(parseInt(strippedValue[j], 10));\n\n\t\t\tconst isLetter = strippedValue[j]\n\t\t\t? strippedValue[j].match(/[A-Z]/i)\n\t\t\t: false;\n\n\t\t\tconst matchesNumber = number.indexOf(placeholder[i]) >= 0;\n\t\t\tconst matchesLetter = letter.indexOf(placeholder[i]) >= 0;\n\n\t\t\tif (matchesNumber && isInt || charset && matchesLetter && isLetter) {\n\t\t\t\tnewValue += strippedValue[j++];\n\t\t\t} else if (!charset && !isInt && matchesNumber || charset && (matchesLetter && !isLetter || matchesNumber && !isInt)) {\n\t\t\t\tconsole.error(\'Invalid Character\');\n\t\t\t\t$$invalidate(3, rawValue = newValue);\n\t\t\t} else {\n\t\t\t\tnewValue += placeholder[i];\n\t\t\t}\n\n\t\t\t// break if no characters left and the pattern is non-special character\n\t\t\tif (strippedValue[j] === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (validExample) {\n\t\t\t$$invalidate(0, value = validateProgress(newValue));\n\t\t}\n\n\t\t$$invalidate(3, rawValue = newValue);\n\t\t$$invalidate(6, remainingMask = placeholder.substring(rawValue.length));\n\t\t$$invalidate(5, currentPattern = usedPattern);\n\t}\n\n\tfunction validateProgress(newValue) {\n\t\tlet testValue = \'\';\n\t\tconst patternRegEx = new RegExp(pattern);\n\n\t\t// Convert to months\n\t\tif (newValue.length === 1 && placeholder.toUpperCase().substring(0, 2) === \'MM\') {\n\t\t\tif (newValue > 1 && newValue < 10) {\n\t\t\t\tnewValue = `0${newValue}`;\n\t\t\t}\n\n\t\t\treturn newValue;\n\t\t}\n\n\t\t// test the value, removing the last character, until what you have is a submatch\n\t\tfor (let i = newValue.length; i >= 0; i--) {\n\t\t\ttestValue = newValue + validExample.substring(newValue.length);\n\n\t\t\tif (patternRegEx.test(testValue)) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\n\t\t\tnewValue = newValue.substring(0, newValue.length - 1);\n\t\t}\n\n\t\treturn newValue;\n\t}\n\n\tfunction input_binding($$value) {\n\t\tbinding_callbacks[$$value ? \'unshift\' : \'push\'](() => {\n\t\t\tinputElement = $$value;\n\t\t\t$$invalidate(4, inputElement);\n\t\t});\n\t}\n\n\t$$self.$$set = $$new_props => {\n\t\t$$props = internal_assign(internal_assign({}, $$props), exclude_internal_props($$new_props));\n\t\t$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));\n\t\tif (\'letter\' in $$new_props) $$invalidate(10, letter = $$new_props.letter);\n\t\tif (\'number\' in $$new_props) $$invalidate(11, number = $$new_props.number);\n\t\tif (\'placeholder\' in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);\n\t\tif (\'validExample\' in $$new_props) $$invalidate(12, validExample = $$new_props.validExample);\n\t\tif (\'value\' in $$new_props) $$invalidate(0, value = $$new_props.value);\n\t\tif (\'charset\' in $$new_props) $$invalidate(13, charset = $$new_props.charset);\n\t\tif (\'pattern\' in $$new_props) $$invalidate(14, pattern = $$new_props.pattern);\n\t\tif (\'prefix\' in $$new_props) $$invalidate(1, prefix = $$new_props.prefix);\n\t\tif (\'required\' in $$new_props) $$invalidate(15, required = $$new_props.required);\n\t};\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty & /*prefix*/ 2) {\n\t\t\t$: $$invalidate(1, prefix = prefix || \'\');\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*prefix, rawValue*/ 10) {\n\t\t\t$: $$invalidate(3, rawValue = prefix && !rawValue ? \' \' : rawValue);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*charset, rawValue*/ 8200) {\n\t\t\t$: $$invalidate(0, value = charset\n\t\t\t? rawValue.replace(/\\W/g, \'\')\n\t\t\t: rawValue.replace(/[^\\d.-]/g, \'\'));\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*prefix, rawValue*/ 10) {\n\t\t\t$: $$invalidate(7, hiddenValue = prefix && rawValue === \' \' ? \'\' : rawValue);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*prefix, placeholder*/ 6) {\n\t\t\t$: $$invalidate(6, remainingMask = prefix ? placeholder.replace(prefix, \'\') : placeholder);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*required, value, pattern*/ 49153) {\n\t\t\t$: usedPattern = required || value ? pattern : null;\n\t\t}\n\t};\n\n\treturn [\n\t\tvalue,\n\t\tprefix,\n\t\tplaceholder,\n\t\trawValue,\n\t\tinputElement,\n\t\tcurrentPattern,\n\t\tremainingMask,\n\t\thiddenValue,\n\t\tupdate,\n\t\t$$restProps,\n\t\tletter,\n\t\tnumber,\n\t\tvalidExample,\n\t\tcharset,\n\t\tpattern,\n\t\trequired,\n\t\tinput_binding\n\t];\n}\n\nclass MaskedInput extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\tinit(\n\t\t\tthis,\n\t\t\toptions,\n\t\t\tinstance,\n\t\t\tcreate_fragment,\n\t\t\tsafe_not_equal,\n\t\t\t{\n\t\t\t\tletter: 10,\n\t\t\t\tnumber: 11,\n\t\t\t\tplaceholder: 2,\n\t\t\t\tvalidExample: 12,\n\t\t\t\tvalue: 0,\n\t\t\t\tcharset: 13,\n\t\t\t\tpattern: 14,\n\t\t\t\tprefix: 1,\n\t\t\t\trequired: 15\n\t\t\t},\n\t\t\tadd_css\n\t\t);\n\t}\n}\n\n/* harmony default export */ const MaskedInput_svelte = (MaskedInput);\n;// CONCATENATED MODULE: ./src/components/FormattedInput.svelte\n/* src/components/FormattedInput.svelte generated by Svelte v3.44.3 */\n\n\nfunction FormattedInput_svelte_add_css(target) {\n\tappend_styles(target, "svelte-43cpcp", ".svelte-43cpcp.svelte-43cpcp:invalid{outline:1px solid red}.shell.svelte-43cpcp.svelte-43cpcp{position:relative;line-height:1}.shell.svelte-43cpcp>span.svelte-43cpcp{position:absolute;top:50%;left:4px;transform:translateY(-50%);color:#ccc;pointer-events:none;z-index:-1}.shell.svelte-43cpcp span i.svelte-43cpcp{font-style:normal;color:transparent;opacity:0;visibility:hidden}input.masked.svelte-43cpcp.svelte-43cpcp,.shell.svelte-43cpcp>span.svelte-43cpcp{font-size:16px;font-family:monospace;padding-right:10px;background-color:transparent;text-transform:uppercase}.suffix.svelte-43cpcp.svelte-43cpcp{color:initial}");\n}\n\nfunction FormattedInput_svelte_create_fragment(ctx) {\n\tlet span2;\n\tlet span1;\n\tlet t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "";\n\tlet t0;\n\tlet i;\n\tlet t1;\n\tlet t2;\n\tlet span0;\n\tlet t3;\n\tlet t4;\n\tlet input;\n\tlet mounted;\n\tlet dispose;\n\n\tlet input_levels = [\n\t\t{ class: "masked" },\n\t\t{ pattern: /*currentPattern*/ ctx[5] },\n\t\t{ value: /*rawValue*/ ctx[2] },\n\t\t/*$$restProps*/ ctx[9]\n\t];\n\n\tlet input_data = {};\n\n\tfor (let i = 0; i < input_levels.length; i += 1) {\n\t\tinput_data = internal_assign(input_data, input_levels[i]);\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tspan2 = internal_element("span");\n\t\t\tspan1 = internal_element("span");\n\t\t\tt0 = internal_text(t0_value);\n\t\t\ti = internal_element("i");\n\t\t\tt1 = internal_text(/*hiddenValue*/ ctx[7]);\n\t\t\tt2 = internal_text(/*remainingMask*/ ctx[6]);\n\t\t\tspan0 = internal_element("span");\n\t\t\tt3 = internal_text(/*suffix*/ ctx[3]);\n\t\t\tt4 = space();\n\t\t\tinput = internal_element("input");\n\t\t\tattr(i, "class", "svelte-43cpcp");\n\t\t\tattr(span0, "class", "suffix svelte-43cpcp");\n\t\t\tattr(span1, "aria-hidden", "true");\n\t\t\tattr(span1, "class", "svelte-43cpcp");\n\t\t\tset_attributes(input, input_data);\n\t\t\ttoggle_class(input, "svelte-43cpcp", true);\n\t\t\tattr(span2, "class", "shell svelte-43cpcp");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, span2, anchor);\n\t\t\tappend(span2, span1);\n\t\t\tappend(span1, t0);\n\t\t\tappend(span1, i);\n\t\t\tappend(i, t1);\n\t\t\tappend(span1, t2);\n\t\t\tappend(span1, span0);\n\t\t\tappend(span0, t3);\n\t\t\tappend(span2, t4);\n\t\t\tappend(span2, input);\n\t\t\tinput.value = input_data.value;\n\t\t\tif (input.autofocus) input.focus();\n\t\t\t/*input_binding*/ ctx[20](input);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = listen(input, "input", /*update*/ ctx[8]);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tif (dirty[0] & /*value, prefix*/ 3 && t0_value !== (t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "")) set_data(t0, t0_value);\n\t\t\tif (dirty[0] & /*hiddenValue*/ 128) set_data(t1, /*hiddenValue*/ ctx[7]);\n\t\t\tif (dirty[0] & /*remainingMask*/ 64) set_data(t2, /*remainingMask*/ ctx[6]);\n\t\t\tif (dirty[0] & /*suffix*/ 8) set_data(t3, /*suffix*/ ctx[3]);\n\n\t\t\tset_attributes(input, input_data = get_spread_update(input_levels, [\n\t\t\t\t{ class: "masked" },\n\t\t\t\tdirty[0] & /*currentPattern*/ 32 && { pattern: /*currentPattern*/ ctx[5] },\n\t\t\t\tdirty[0] & /*rawValue*/ 4 && input.value !== /*rawValue*/ ctx[2] && { value: /*rawValue*/ ctx[2] },\n\t\t\t\tdirty[0] & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]\n\t\t\t]));\n\n\t\t\tif (\'value\' in input_data) {\n\t\t\t\tinput.value = input_data.value;\n\t\t\t}\n\n\t\t\ttoggle_class(input, "svelte-43cpcp", true);\n\t\t},\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(span2);\n\t\t\t/*input_binding*/ ctx[20](null);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n}\n\nfunction FormattedInput_svelte_instance($$self, $$props, $$invalidate) {\n\tlet suffix;\n\tlet hiddenValue;\n\tlet placeholderDecimal;\n\tlet placeholderDecimalLength;\n\tlet usedPattern;\n\n\tconst omit_props_names = [\n\t\t"placeholder","value","pattern","format","prefix","required","formatter","locale","currency","formatOptions"\n\t];\n\n\tlet $$restProps = compute_rest_props($$props, omit_props_names);\n\tlet { placeholder = \'\' } = $$props;\n\tlet { value = \'\' } = $$props;\n\tlet { pattern = \'\' } = $$props;\n\tlet { format = \'\' } = $$props;\n\tlet { prefix = \'\' } = $$props;\n\tlet { required = false } = $$props;\n\tlet { formatter = null } = $$props;\n\tlet { locale = \'en-us\' } = $$props;\n\tlet { currency = \'USD\' } = $$props;\n\tlet { formatOptions = null } = $$props;\n\tlet rawValue = \'\';\n\tlet inputElement;\n\tlet currentPattern = null;\n\tlet remainingMask = placeholder;\n\tlet significantDigits = 1;\n\tlet decimalRegExp = null;\n\tlet decimalEndRegExp = null;\n\tlet seperators = {};\n\tconst log10 = Math.log(10);\n\n\tfunction getSeperators(_) {\n\t\tconst numberWithGroupAndDecimalSeparator = 1000.1;\n\n\t\treturn Intl.NumberFormat(locale).formatToParts(numberWithGroupAndDecimalSeparator).reduce(\n\t\t\t(collection, part) => {\n\t\t\t\tif (part.type === \'decimal\' || part.type === \'group\') {\n\t\t\t\t\tcollection[part.type] = part.value;\n\t\t\t\t}\n\n\t\t\t\treturn collection;\n\t\t\t},\n\t\t\t{}\n\t\t);\n\t}\n\n\tfunction getSignificantDigitCount(n) {\n\t\tn = Math.abs(parseFloat(String(n).replace(seperators.decimal, \'\')));\n\n\t\tif (n === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (n !== 0 && n % 10 === 0) {\n\t\t\tn /= 10;\n\t\t}\n\n\t\treturn Math.floor(Math.log(n) / log10) + 1;\n\t}\n\n\tconst formats = {\n\t\tcurrency(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\t{\n\t\t\t\t\tcurrency,\n\t\t\t\t\tmaximumFractionDigits: 2,\n\t\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\t\tstyle: \'currency\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tcurrencyInt(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\t{\n\t\t\t\t\tcurrency,\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\t\tstyle: \'currency\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tint(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\t{\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\t\tstyle: \'decimal\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tnumber(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\t{\n\t\t\t\t\tminimumSignificantDigits: significantDigits,\n\t\t\t\t\tstyle: \'decimal\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tpercent(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\t{\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t\tstyle: \'percent\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tpercentInt(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale, formatOptions || { style: \'percent\' });\n\t\t\treturn formatFunction.format(input);\n\t\t}\n\t};\n\n\tfunction formatDecimals(currentFormatter) {\n\t\tconst isDecimal = decimalEndRegExp.test(inputElement.value);\n\t\tconst hasDecimal = decimalRegExp.test(inputElement.value);\n\t\tconst usedValue = isDecimal ? value.slice(0, -1) : value;\n\t\tconst intValue = parseFloat(usedValue);\n\n\t\tconst digits = intValue > 0\n\t\t? getSignificantDigitCount(value) + 1\n\t\t: Math.min(4, hasDecimal ? value.length - 1 : value.length);\n\n\t\tif (Number.isNaN(intValue)) {\n\t\t\t$$invalidate(6, remainingMask = placeholder);\n\t\t\treturn \'\';\n\t\t}\n\n\t\t$$invalidate(6, remainingMask = `${isDecimal ? \'\' : seperators.decimal}${placeholderDecimal}`);\n\t\tsignificantDigits = !(/0$/).test(rawValue) ? undefined : digits;\n\n\t\tif (hasDecimal && !isDecimal) {\n\t\t\tconst decimalLength = rawValue.split(seperators.decimal)[1].length;\n\t\t\tconst remainingDecimals = placeholderDecimalLength - decimalLength;\n\n\t\t\t$$invalidate(6, remainingMask = `${remainingDecimals > 0\n\t\t\t? placeholderDecimal.slice(-1 * decimalLength)\n\t\t\t: \'\'}`);\n\t\t}\n\n\t\treturn `${currentFormatter(intValue)}${isDecimal ? seperators.decimal : \'\'}`;\n\t}\n\n\tconst formatters = {\n\t\tcurrency: {\n\t\t\tformat() {\n\t\t\t\treturn formatDecimals(formats.currency);\n\t\t\t},\n\t\t\tpattern: \'\\\\$[0-9]{1,3}(,[0-9]{3}){0,}\',\n\t\t\tprefix: \'$\'\n\t\t},\n\t\tcurrencyInt: {\n\t\t\tformat() {\n\t\t\t\tconst intValue = parseInt(value, 10);\n\n\t\t\t\tif (Number.isNaN(intValue)) {\n\t\t\t\t\treturn \' \';\n\t\t\t\t}\n\n\t\t\t\tif (placeholder.length <= rawValue.length) {\n\t\t\t\t\t$$invalidate(6, remainingMask = \'\');\n\t\t\t\t} else {\n\t\t\t\t\tconst remainingMaskLength = placeholder.length - rawValue.length;\n\t\t\t\t\t$$invalidate(6, remainingMask = placeholder.slice(-1 * remainingMaskLength));\n\t\t\t\t}\n\n\t\t\t\treturn formats.currencyInt(intValue);\n\t\t\t},\n\t\t\tpattern: \'\\\\$[0-9]{1,3}(,[0-9]{3}){0,}\',\n\t\t\tprefix: \'$\'\n\t\t},\n\t\tint: {\n\t\t\tformat() {\n\t\t\t\tconst intValue = parseInt(value, 10);\n\n\t\t\t\tif (Number.isNaN(intValue)) {\n\t\t\t\t\treturn \' \';\n\t\t\t\t}\n\n\t\t\t\tif (placeholder.length <= rawValue.length) {\n\t\t\t\t\t$$invalidate(6, remainingMask = \'\');\n\t\t\t\t} else {\n\t\t\t\t\tconst remainingMaskLength = placeholder.length - rawValue.length;\n\t\t\t\t\t$$invalidate(6, remainingMask = placeholder.slice(-1 * remainingMaskLength));\n\t\t\t\t}\n\n\t\t\t\treturn formats.int(intValue);\n\t\t\t},\n\t\t\tpattern: \'[0-9]{1,3}(,[0-9]{3})*\\\\.[0-9]\'\n\t\t},\n\t\tnumber: {\n\t\t\tformat() {\n\t\t\t\treturn formatDecimals(formats.number);\n\t\t\t},\n\t\t\tpattern: \'[0-9]{1,3}(,[0-9]{3})*(\\\\.[0-9]+)?$\'\n\t\t},\n\t\tpercentInt: {\n\t\t\tformat() {\n\t\t\t\tconst intValue = parseInt(value, 10);\n\n\t\t\t\tif (Number.isNaN(intValue)) {\n\t\t\t\t\treturn \' \';\n\t\t\t\t}\n\n\t\t\t\tif (placeholder.length <= rawValue.length) {\n\t\t\t\t\t$$invalidate(6, remainingMask = \'\');\n\t\t\t\t} else {\n\t\t\t\t\tconst remainingMaskLength = placeholder.length - rawValue.length;\n\t\t\t\t\t$$invalidate(6, remainingMask = placeholder.slice(-1 * remainingMaskLength));\n\t\t\t\t}\n\n\t\t\t\treturn `${formats.int(intValue)}`;\n\t\t\t},\n\t\t\tsuffix: \'%\',\n\t\t\tpattern: \'[0-9]{1,})%\'\n\t\t}\n\t};\n\n\tvalue = rawValue.replace(/[^\\d.-]/g, \'\');\n\trawValue = prefix && !rawValue ? \' \' : rawValue;\n\tremainingMask = prefix ? placeholder.replace(prefix, \'\') : placeholder;\n\n\tasync function update() {\n\t\t$$invalidate(0, value = inputElement.value.replace(/[^\\d.-]/g, \'\'));\n\t\t$$invalidate(5, currentPattern = null);\n\t\t$$invalidate(2, rawValue = formatters[format].format());\n\t\t$$invalidate(5, currentPattern = usedPattern);\n\t}\n\n\tfunction input_binding($$value) {\n\t\tbinding_callbacks[$$value ? \'unshift\' : \'push\'](() => {\n\t\t\tinputElement = $$value;\n\t\t\t$$invalidate(4, inputElement);\n\t\t});\n\t}\n\n\t$$self.$$set = $$new_props => {\n\t\t$$props = internal_assign(internal_assign({}, $$props), exclude_internal_props($$new_props));\n\t\t$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));\n\t\tif (\'placeholder\' in $$new_props) $$invalidate(11, placeholder = $$new_props.placeholder);\n\t\tif (\'value\' in $$new_props) $$invalidate(0, value = $$new_props.value);\n\t\tif (\'pattern\' in $$new_props) $$invalidate(12, pattern = $$new_props.pattern);\n\t\tif (\'format\' in $$new_props) $$invalidate(13, format = $$new_props.format);\n\t\tif (\'prefix\' in $$new_props) $$invalidate(1, prefix = $$new_props.prefix);\n\t\tif (\'required\' in $$new_props) $$invalidate(14, required = $$new_props.required);\n\t\tif (\'formatter\' in $$new_props) $$invalidate(10, formatter = $$new_props.formatter);\n\t\tif (\'locale\' in $$new_props) $$invalidate(15, locale = $$new_props.locale);\n\t\tif (\'currency\' in $$new_props) $$invalidate(16, currency = $$new_props.currency);\n\t\tif (\'formatOptions\' in $$new_props) $$invalidate(17, formatOptions = $$new_props.formatOptions);\n\t};\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty[0] & /*locale*/ 32768) {\n\t\t\t$: $$invalidate(18, seperators = getSeperators(locale));\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*formatter, format*/ 9216) {\n\t\t\t$: formatter || $$invalidate(10, formatter = formatters[format]);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*format, prefix*/ 8194) {\n\t\t\t$: $$invalidate(1, prefix = format ? formatters[format].prefix || \'\' : prefix || \'\');\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*format, suffix*/ 8200) {\n\t\t\t$: $$invalidate(3, suffix = format ? formatters[format].suffix || \'\' : suffix || \'\');\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*prefix, rawValue*/ 6) {\n\t\t\t$: $$invalidate(7, hiddenValue = prefix && rawValue === \' \' ? \'\' : rawValue);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*seperators*/ 262144) {\n\t\t\t$: decimalEndRegExp = new RegExp(`\\\\${seperators.decimal}$`);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*seperators*/ 262144) {\n\t\t\t$: decimalRegExp = new RegExp(`\\\\${seperators.decimal}`);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*placeholder, seperators*/ 264192) {\n\t\t\t$: $$invalidate(19, placeholderDecimal = placeholder === null || placeholder === void 0\n\t\t\t? void 0\n\t\t\t: placeholder.split(seperators.decimal)[1]);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*placeholderDecimal*/ 524288) {\n\t\t\t$: placeholderDecimalLength = placeholderDecimal === null || placeholderDecimal === void 0\n\t\t\t? void 0\n\t\t\t: placeholderDecimal.length;\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*required, value, format, pattern*/ 28673) {\n\t\t\t$: usedPattern = required || value\n\t\t\t? format ? pattern || formatters[format].pattern : pattern\n\t\t\t: null;\n\t\t}\n\t};\n\n\treturn [\n\t\tvalue,\n\t\tprefix,\n\t\trawValue,\n\t\tsuffix,\n\t\tinputElement,\n\t\tcurrentPattern,\n\t\tremainingMask,\n\t\thiddenValue,\n\t\tupdate,\n\t\t$$restProps,\n\t\tformatter,\n\t\tplaceholder,\n\t\tpattern,\n\t\tformat,\n\t\trequired,\n\t\tlocale,\n\t\tcurrency,\n\t\tformatOptions,\n\t\tseperators,\n\t\tplaceholderDecimal,\n\t\tinput_binding\n\t];\n}\n\nclass FormattedInput extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\tinit(\n\t\t\tthis,\n\t\t\toptions,\n\t\t\tFormattedInput_svelte_instance,\n\t\t\tFormattedInput_svelte_create_fragment,\n\t\t\tsafe_not_equal,\n\t\t\t{\n\t\t\t\tplaceholder: 11,\n\t\t\t\tvalue: 0,\n\t\t\t\tpattern: 12,\n\t\t\t\tformat: 13,\n\t\t\t\tprefix: 1,\n\t\t\t\trequired: 14,\n\t\t\t\tformatter: 10,\n\t\t\t\tlocale: 15,\n\t\t\t\tcurrency: 16,\n\t\t\t\tformatOptions: 17\n\t\t\t},\n\t\t\tFormattedInput_svelte_add_css,\n\t\t\t[-1, -1]\n\t\t);\n\t}\n}\n\n/* harmony default export */ const FormattedInput_svelte = (FormattedInput);\n;// CONCATENATED MODULE: ./src/App.svelte\n/* src/App.svelte generated by Svelte v3.44.3 */\n\n\n\n\n\nfunction App_svelte_add_css(target) {\n\tappend_styles(target, "svelte-1nmrny4", ".svelte-1nmrny4.svelte-1nmrny4{box-sizing:border-box}main.svelte-1nmrny4.svelte-1nmrny4{text-align:center;padding:1em;margin:0 auto}h1.svelte-1nmrny4.svelte-1nmrny4{color:#ff3e00;font-size:4em;font-weight:900}h2.svelte-1nmrny4.svelte-1nmrny4{font-size:2.5em}h1.svelte-1nmrny4.svelte-1nmrny4,h2.svelte-1nmrny4.svelte-1nmrny4{font-family:\\"Cutive Mono\\", monospace}body *{font-family:\\"Cutive Mono\\", monospace !important}body p{font-size:1.5rem;font-family:\\"Noto Sans JP\\", sans-serif !important}@media(min-width: 640px){main.svelte-1nmrny4.svelte-1nmrny4{max-width:none}}.grid.svelte-1nmrny4.svelte-1nmrny4{display:grid;grid-template-columns:1fr}@media(min-width: 640px){.grid.svelte-1nmrny4.svelte-1nmrny4{grid-template-columns:1fr 1fr}}li.svelte-1nmrny4>label.svelte-1nmrny4:first-child{font-size:1.25rem;display:block;font-family:\\"Noto Serif JP\\", serif !important;margin-bottom:0.5rem}.item.svelte-1nmrny4.svelte-1nmrny4{margin:2rem}img.svelte-1nmrny4.svelte-1nmrny4{width:400px}ul.svelte-1nmrny4.svelte-1nmrny4{list-style:none;padding:0}input,.shell span{padding:0.25rem;border-radius:0.25rem}li.svelte-1nmrny4.svelte-1nmrny4{text-align:left;margin-bottom:1rem}pre.svelte-1nmrny4.svelte-1nmrny4{display:none;background:black;color:white;padding:1rem;border:4px inset red}input.svelte-1nmrny4:checked+pre.svelte-1nmrny4{display:block}.toggle.svelte-1nmrny4.svelte-1nmrny4{border:1px solid;padding:0.25rem;border-radius:0.25rem;font-weight:900;cursor:pointer}.toggle.svelte-1nmrny4.svelte-1nmrny4:hover{background:#eee}.toggle.svelte-1nmrny4.svelte-1nmrny4:active{background:#333;color:white}input[type=checkbox].svelte-1nmrny4.svelte-1nmrny4{display:none}");\n}\n\nfunction App_svelte_create_fragment(ctx) {\n\tlet main;\n\tlet img;\n\tlet img_src_value;\n\tlet t0;\n\tlet h1;\n\tlet t2;\n\tlet p;\n\tlet t4;\n\tlet div2;\n\tlet div0;\n\tlet h20;\n\tlet t6;\n\tlet hr0;\n\tlet t7;\n\tlet ul0;\n\tlet li0;\n\tlet label0;\n\tlet t9;\n\tlet maskedinput0;\n\tlet t10;\n\tlet label1;\n\tlet input0;\n\tlet t12;\n\tlet pre0;\n\tlet t14;\n\tlet li1;\n\tlet label2;\n\tlet t16;\n\tlet maskedinput1;\n\tlet t17;\n\tlet label3;\n\tlet input1;\n\tlet t19;\n\tlet pre1;\n\tlet code1;\n\tlet t23;\n\tlet li2;\n\tlet label4;\n\tlet t25;\n\tlet maskedinput2;\n\tlet t26;\n\tlet label5;\n\tlet input2;\n\tlet t28;\n\tlet pre2;\n\tlet t30;\n\tlet li3;\n\tlet label6;\n\tlet t32;\n\tlet maskedinput3;\n\tlet t33;\n\tlet label7;\n\tlet input3;\n\tlet t35;\n\tlet pre3;\n\tlet code3;\n\tlet t43;\n\tlet li4;\n\tlet label8;\n\tlet t45;\n\tlet maskedinput4;\n\tlet t46;\n\tlet label9;\n\tlet input4;\n\tlet t48;\n\tlet pre4;\n\tlet code4;\n\tlet t58;\n\tlet div1;\n\tlet h21;\n\tlet t60;\n\tlet hr1;\n\tlet t61;\n\tlet ul1;\n\tlet li5;\n\tlet label10;\n\tlet t63;\n\tlet formattedinput0;\n\tlet t64;\n\tlet label11;\n\tlet input5;\n\tlet t66;\n\tlet pre5;\n\tlet t68;\n\tlet li6;\n\tlet label12;\n\tlet t70;\n\tlet formattedinput1;\n\tlet t71;\n\tlet label13;\n\tlet input6;\n\tlet t73;\n\tlet pre6;\n\tlet t75;\n\tlet li7;\n\tlet label14;\n\tlet t77;\n\tlet formattedinput2;\n\tlet t78;\n\tlet label15;\n\tlet input7;\n\tlet t80;\n\tlet pre7;\n\tlet t82;\n\tlet li8;\n\tlet label16;\n\tlet t84;\n\tlet formattedinput3;\n\tlet t85;\n\tlet label17;\n\tlet input8;\n\tlet t87;\n\tlet pre8;\n\tlet t89;\n\tlet li9;\n\tlet label18;\n\tlet t91;\n\tlet formattedinput4;\n\tlet t92;\n\tlet label19;\n\tlet input9;\n\tlet t94;\n\tlet pre9;\n\tlet current;\n\n\tmaskedinput0 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "cc-exp",\n\t\t\t\ttype: "tel",\n\t\t\t\tplaceholder: "MM/YY",\n\t\t\t\tpattern: "(1[0-2]|0[1-9])\\\\/\\\\d\\\\d",\n\t\t\t\tvalidExample: "11/18",\n\t\t\t\ttitle: "2-digit month and 2-digit year greater than 01/15"\n\t\t\t}\n\t\t});\n\n\tmaskedinput1 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "zip",\n\t\t\t\ttype: "tel",\n\t\t\t\tplaceholder: "XXXXX",\n\t\t\t\tpattern: "\\\\d" + 5,\n\t\t\t\ttitle: "5-digit zip code"\n\t\t\t}\n\t\t});\n\n\tmaskedinput2 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "ca-zip",\n\t\t\t\tplaceholder: "XXX XXX",\n\t\t\t\tpattern: "\\\\w\\\\d\\\\w \\\\d\\\\w\\\\d",\n\t\t\t\tcharset: "_X_ X_X",\n\t\t\t\ttitle: "6-character alphanumeric zip code in the format of A1A 1A1"\n\t\t\t}\n\t\t});\n\n\tmaskedinput3 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "tel",\n\t\t\t\tplaceholder: "(XXX) XXX-XXXX",\n\t\t\t\tpattern: "\\\\(\\\\d" + 3 + "\\\\) \\\\d" + 3 + "\\\\-\\\\d" + 4,\n\t\t\t\ttitle: "10-digit number"\n\t\t\t}\n\t\t});\n\n\tmaskedinput4 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "cc",\n\t\t\t\tplaceholder: "XXXX XXXX XXXX XXXX",\n\t\t\t\tpattern: "\\\\d" + 4 + " \\\\d" + 4 + " \\\\d" + 4 + " \\\\d" + 4,\n\t\t\t\ttitle: "16-digit number"\n\t\t\t}\n\t\t});\n\n\tformattedinput0 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "number",\n\t\t\t\tplaceholder: "0.00",\n\t\t\t\tformat: "number"\n\t\t\t}\n\t\t});\n\n\tformattedinput1 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "int",\n\t\t\t\tplaceholder: "X",\n\t\t\t\tformat: "int"\n\t\t\t}\n\t\t});\n\n\tformattedinput2 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "currency",\n\t\t\t\tplaceholder: "$X.XX",\n\t\t\t\tformat: "currency"\n\t\t\t}\n\t\t});\n\n\tformattedinput3 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "currencyInt",\n\t\t\t\tplaceholder: "$X",\n\t\t\t\tformat: "currencyInt"\n\t\t\t}\n\t\t});\n\n\tformattedinput4 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "currencyInt",\n\t\t\t\tplaceholder: "X",\n\t\t\t\tformat: "percentInt"\n\t\t\t}\n\t\t});\n\n\treturn {\n\t\tc() {\n\t\t\tmain = internal_element("main");\n\t\t\timg = internal_element("img");\n\t\t\tt0 = space();\n\t\t\th1 = internal_element("h1");\n\t\t\th1.textContent = "Svelte Masked Input";\n\t\t\tt2 = space();\n\t\t\tp = internal_element("p");\n\t\t\tp.textContent = "Cybernetically Enhanced Inputs with Masks for Svelte Apps";\n\t\t\tt4 = space();\n\t\t\tdiv2 = internal_element("div");\n\t\t\tdiv0 = internal_element("div");\n\t\t\th20 = internal_element("h2");\n\t\t\th20.textContent = "Masked Inputs";\n\t\t\tt6 = space();\n\t\t\thr0 = internal_element("hr");\n\t\t\tt7 = space();\n\t\t\tul0 = internal_element("ul");\n\t\t\tli0 = internal_element("li");\n\t\t\tlabel0 = internal_element("label");\n\t\t\tlabel0.textContent = "Credit Card Expiration Month";\n\t\t\tt9 = space();\n\t\t\tcreate_component(maskedinput0.$$.fragment);\n\t\t\tt10 = space();\n\t\t\tlabel1 = internal_element("label");\n\t\t\tlabel1.textContent = "Show Markup";\n\t\t\tinput0 = internal_element("input");\n\t\t\tt12 = space();\n\t\t\tpre0 = internal_element("pre");\n\n\t\t\tpre0.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;cc-exp&quot;&gt;Credit Card Expiration Month&lt;/label&gt;\n&lt;MaskedInput\n    id=&quot;cc-exp&quot;\n    pattern=&quot;(1[0-2]|0[1-9])\\\\/\\\\d\\\\d&quot;\n    placeholder=&quot;MM/YY&quot;\n    title=&quot;2-digit month and 2-digit year greater than 01/15&quot;\n    type=&quot;tel&quot;\n    validExample=&quot;11/18&quot;\n/&gt;</code>`;\n\n\t\t\tt14 = space();\n\t\t\tli1 = internal_element("li");\n\t\t\tlabel2 = internal_element("label");\n\t\t\tlabel2.textContent = "Zip Code";\n\t\t\tt16 = space();\n\t\t\tcreate_component(maskedinput1.$$.fragment);\n\t\t\tt17 = space();\n\t\t\tlabel3 = internal_element("label");\n\t\t\tlabel3.textContent = "Show Markup";\n\t\t\tinput1 = internal_element("input");\n\t\t\tt19 = space();\n\t\t\tpre1 = internal_element("pre");\n\t\t\tcode1 = internal_element("code");\n\n\t\t\tcode1.textContent = `<label for="zip">Zip Code</label>\n<MaskedInput\n    id="zip"\n    type="tel"\n    placeholder="XXXXX"\n    pattern="\\\\d${5}"\n    title="5-digit zip code"\n/>`;\n\n\t\t\tt23 = space();\n\t\t\tli2 = internal_element("li");\n\t\t\tlabel4 = internal_element("label");\n\t\t\tlabel4.textContent = "Canadian Zip Code";\n\t\t\tt25 = space();\n\t\t\tcreate_component(maskedinput2.$$.fragment);\n\t\t\tt26 = space();\n\t\t\tlabel5 = internal_element("label");\n\t\t\tlabel5.textContent = "Show Markup";\n\t\t\tinput2 = internal_element("input");\n\t\t\tt28 = space();\n\t\t\tpre2 = internal_element("pre");\n\n\t\t\tpre2.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;ca-zip&quot;&gt;Canadian Zip Code&lt;/label&gt;\n&lt;MaskedInput\n    charset=&quot;_X_ X_X&quot;\n    id=&quot;ca-zip&quot;\n    pattern=&quot;\\\\w\\\\d\\\\w \\\\d\\\\w\\\\d&quot;\n    placeholder=&quot;XXX XXX&quot;\n    title=&quot;6-character alphanumeric zip code in the format of A1A 1A1&quot;\n/&gt;</code>`;\n\n\t\t\tt30 = space();\n\t\t\tli3 = internal_element("li");\n\t\t\tlabel6 = internal_element("label");\n\t\t\tlabel6.textContent = "Telephone";\n\t\t\tt32 = space();\n\t\t\tcreate_component(maskedinput3.$$.fragment);\n\t\t\tt33 = space();\n\t\t\tlabel7 = internal_element("label");\n\t\t\tlabel7.textContent = "Show Markup";\n\t\t\tinput3 = internal_element("input");\n\t\t\tt35 = space();\n\t\t\tpre3 = internal_element("pre");\n\t\t\tcode3 = internal_element("code");\n\n\t\t\tcode3.textContent = `<label for="tel">Telephone</label>\n<MaskedInput\n    id="tel"\n    pattern="\\\\(\\\\d${3}\\\\) \\\\d${3}\\\\-\\\\d${4}"\n    placeholder="(XXX) XXX-XXXX"\n    title="10-digit number"\n/>`;\n\n\t\t\tt43 = space();\n\t\t\tli4 = internal_element("li");\n\t\t\tlabel8 = internal_element("label");\n\t\t\tlabel8.textContent = "Credit Card Number";\n\t\t\tt45 = space();\n\t\t\tcreate_component(maskedinput4.$$.fragment);\n\t\t\tt46 = space();\n\t\t\tlabel9 = internal_element("label");\n\t\t\tlabel9.textContent = "Show Markup";\n\t\t\tinput4 = internal_element("input");\n\t\t\tt48 = space();\n\t\t\tpre4 = internal_element("pre");\n\t\t\tcode4 = internal_element("code");\n\n\t\t\tcode4.textContent = `<label for="cc">Credit Card Number</label>\n<MaskedInput\n    id="cc"\n    pattern="\\\\d${4} \\\\d${4} \\\\d${4} \\\\d${4}"\n    placeholder="XXXX XXXX XXXX XXXX"\n    title="16-digit number"\n/>`;\n\n\t\t\tt58 = space();\n\t\t\tdiv1 = internal_element("div");\n\t\t\th21 = internal_element("h2");\n\t\t\th21.textContent = "Formatted Inputs";\n\t\t\tt60 = space();\n\t\t\thr1 = internal_element("hr");\n\t\t\tt61 = space();\n\t\t\tul1 = internal_element("ul");\n\t\t\tli5 = internal_element("li");\n\t\t\tlabel10 = internal_element("label");\n\t\t\tlabel10.textContent = "Number";\n\t\t\tt63 = space();\n\t\t\tcreate_component(formattedinput0.$$.fragment);\n\t\t\tt64 = space();\n\t\t\tlabel11 = internal_element("label");\n\t\t\tlabel11.textContent = "Show Markup";\n\t\t\tinput5 = internal_element("input");\n\t\t\tt66 = space();\n\t\t\tpre5 = internal_element("pre");\n\n\t\t\tpre5.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;number&quot;&gt;Number&lt;/label&gt;\n&lt;FormattedInput id=&quot;number&quot; placeholder=&quot;0.00&quot; format=&quot;number&quot; /&gt;</code>`;\n\n\t\t\tt68 = space();\n\t\t\tli6 = internal_element("li");\n\t\t\tlabel12 = internal_element("label");\n\t\t\tlabel12.textContent = "Int";\n\t\t\tt70 = space();\n\t\t\tcreate_component(formattedinput1.$$.fragment);\n\t\t\tt71 = space();\n\t\t\tlabel13 = internal_element("label");\n\t\t\tlabel13.textContent = "Show Markup";\n\t\t\tinput6 = internal_element("input");\n\t\t\tt73 = space();\n\t\t\tpre6 = internal_element("pre");\n\n\t\t\tpre6.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;int&quot;&gt;Int&lt;/label&gt;\n&lt;FormattedInput id=&quot;int&quot; placeholder=&quot;X&quot; format=&quot;int&quot; /&gt;</code>`;\n\n\t\t\tt75 = space();\n\t\t\tli7 = internal_element("li");\n\t\t\tlabel14 = internal_element("label");\n\t\t\tlabel14.textContent = "Currency";\n\t\t\tt77 = space();\n\t\t\tcreate_component(formattedinput2.$$.fragment);\n\t\t\tt78 = space();\n\t\t\tlabel15 = internal_element("label");\n\t\t\tlabel15.textContent = "Show Markup";\n\t\t\tinput7 = internal_element("input");\n\t\t\tt80 = space();\n\t\t\tpre7 = internal_element("pre");\n\n\t\t\tpre7.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;currency&quot;&gt;Currency&lt;/label&gt;\n&lt;FormattedInput id=&quot;currency&quot; placeholder=&quot;\\$X.XX&quot; format=&quot;currency&quot; /&gt;</code>`;\n\n\t\t\tt82 = space();\n\t\t\tli8 = internal_element("li");\n\t\t\tlabel16 = internal_element("label");\n\t\t\tlabel16.textContent = "Currency Int";\n\t\t\tt84 = space();\n\t\t\tcreate_component(formattedinput3.$$.fragment);\n\t\t\tt85 = space();\n\t\t\tlabel17 = internal_element("label");\n\t\t\tlabel17.textContent = "Show Markup";\n\t\t\tinput8 = internal_element("input");\n\t\t\tt87 = space();\n\t\t\tpre8 = internal_element("pre");\n\n\t\t\tpre8.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;currencyInt&quot;&gt;Currency Int&lt;/label&gt;\n&lt;FormattedInput id=&quot;currencyInt&quot; placeholder=&quot;\\$X&quot; format=&quot;currencyInt&quot; /&gt;</code>`;\n\n\t\t\tt89 = space();\n\t\t\tli9 = internal_element("li");\n\t\t\tlabel18 = internal_element("label");\n\t\t\tlabel18.textContent = "Percent Int";\n\t\t\tt91 = space();\n\t\t\tcreate_component(formattedinput4.$$.fragment);\n\t\t\tt92 = space();\n\t\t\tlabel19 = internal_element("label");\n\t\t\tlabel19.textContent = "Show Markup";\n\t\t\tinput9 = internal_element("input");\n\t\t\tt94 = space();\n\t\t\tpre9 = internal_element("pre");\n\n\t\t\tpre9.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;currencyInt&quot;&gt;Percent Int&lt;/label&gt;\n&lt;FormattedInput id=&quot;currencyInt&quot; placeholder=&quot;X&quot; format=&quot;percentInt&quot; /&gt;</code>`;\n\n\t\t\tif (!src_url_equal(img.src, img_src_value = "/masked-input-logo.svg")) attr(img, "src", img_src_value);\n\t\t\tattr(img, "alt", "logo");\n\t\t\tattr(img, "class", "svelte-1nmrny4");\n\t\t\tattr(h1, "class", "svelte-1nmrny4");\n\t\t\tattr(p, "class", "svelte-1nmrny4");\n\t\t\tattr(h20, "class", "svelte-1nmrny4");\n\t\t\tattr(hr0, "class", "svelte-1nmrny4");\n\t\t\tattr(label0, "for", "cc-exp");\n\t\t\tattr(label0, "class", "svelte-1nmrny4");\n\t\t\tattr(label1, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label1, "for", "cc-exp-markup");\n\t\t\tattr(input0, "id", "cc-exp-markup");\n\t\t\tattr(input0, "type", "checkbox");\n\t\t\tattr(input0, "class", "svelte-1nmrny4");\n\t\t\tattr(pre0, "class", "svelte-1nmrny4");\n\t\t\tattr(li0, "class", "svelte-1nmrny4");\n\t\t\tattr(label2, "for", "zip");\n\t\t\tattr(label2, "class", "svelte-1nmrny4");\n\t\t\tattr(label3, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label3, "for", "zip-markup");\n\t\t\tattr(input1, "id", "zip-markup");\n\t\t\tattr(input1, "type", "checkbox");\n\t\t\tattr(input1, "class", "svelte-1nmrny4");\n\t\t\tattr(code1, "class", "svelte-1nmrny4");\n\t\t\tattr(pre1, "class", "svelte-1nmrny4");\n\t\t\tattr(li1, "class", "svelte-1nmrny4");\n\t\t\tattr(label4, "for", "ca-zip");\n\t\t\tattr(label4, "class", "svelte-1nmrny4");\n\t\t\tattr(label5, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label5, "for", "ca-zip-markup");\n\t\t\tattr(input2, "id", "ca-zip-markup");\n\t\t\tattr(input2, "type", "checkbox");\n\t\t\tattr(input2, "class", "svelte-1nmrny4");\n\t\t\tattr(pre2, "class", "svelte-1nmrny4");\n\t\t\tattr(li2, "class", "svelte-1nmrny4");\n\t\t\tattr(label6, "for", "tel");\n\t\t\tattr(label6, "class", "svelte-1nmrny4");\n\t\t\tattr(label7, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label7, "for", "tel-markup");\n\t\t\tattr(input3, "id", "tel-markup");\n\t\t\tattr(input3, "type", "checkbox");\n\t\t\tattr(input3, "class", "svelte-1nmrny4");\n\t\t\tattr(code3, "class", "svelte-1nmrny4");\n\t\t\tattr(pre3, "class", "svelte-1nmrny4");\n\t\t\tattr(li3, "class", "svelte-1nmrny4");\n\t\t\tattr(label8, "for", "cc");\n\t\t\tattr(label8, "class", "svelte-1nmrny4");\n\t\t\tattr(label9, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label9, "for", "cc-markup");\n\t\t\tattr(input4, "id", "cc-markup");\n\t\t\tattr(input4, "type", "checkbox");\n\t\t\tattr(input4, "class", "svelte-1nmrny4");\n\t\t\tattr(code4, "class", "svelte-1nmrny4");\n\t\t\tattr(pre4, "class", "svelte-1nmrny4");\n\t\t\tattr(li4, "class", "svelte-1nmrny4");\n\t\t\tattr(ul0, "class", "svelte-1nmrny4");\n\t\t\tattr(div0, "class", "item svelte-1nmrny4");\n\t\t\tattr(h21, "class", "svelte-1nmrny4");\n\t\t\tattr(hr1, "class", "svelte-1nmrny4");\n\t\t\tattr(label10, "for", "number");\n\t\t\tattr(label10, "class", "svelte-1nmrny4");\n\t\t\tattr(label11, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label11, "for", "number-markup");\n\t\t\tattr(input5, "id", "number-markup");\n\t\t\tattr(input5, "type", "checkbox");\n\t\t\tattr(input5, "class", "svelte-1nmrny4");\n\t\t\tattr(pre5, "class", "svelte-1nmrny4");\n\t\t\tattr(li5, "class", "svelte-1nmrny4");\n\t\t\tattr(label12, "for", "int");\n\t\t\tattr(label12, "class", "svelte-1nmrny4");\n\t\t\tattr(label13, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label13, "for", "int-markup");\n\t\t\tattr(input6, "id", "int-markup");\n\t\t\tattr(input6, "type", "checkbox");\n\t\t\tattr(input6, "class", "svelte-1nmrny4");\n\t\t\tattr(pre6, "class", "svelte-1nmrny4");\n\t\t\tattr(li6, "class", "svelte-1nmrny4");\n\t\t\tattr(label14, "for", "currency");\n\t\t\tattr(label14, "class", "svelte-1nmrny4");\n\t\t\tattr(label15, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label15, "for", "currency-markup");\n\t\t\tattr(input7, "id", "currency-markup");\n\t\t\tattr(input7, "type", "checkbox");\n\t\t\tattr(input7, "class", "svelte-1nmrny4");\n\t\t\tattr(pre7, "class", "svelte-1nmrny4");\n\t\t\tattr(li7, "class", "svelte-1nmrny4");\n\t\t\tattr(label16, "for", "currencyInt");\n\t\t\tattr(label16, "class", "svelte-1nmrny4");\n\t\t\tattr(label17, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label17, "for", "currency-int-markup");\n\t\t\tattr(input8, "id", "currency-int-markup");\n\t\t\tattr(input8, "type", "checkbox");\n\t\t\tattr(input8, "class", "svelte-1nmrny4");\n\t\t\tattr(pre8, "class", "svelte-1nmrny4");\n\t\t\tattr(li8, "class", "svelte-1nmrny4");\n\t\t\tattr(label18, "for", "currencyInt");\n\t\t\tattr(label18, "class", "svelte-1nmrny4");\n\t\t\tattr(label19, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label19, "for", "percent-int-markup");\n\t\t\tattr(input9, "id", "percent-int-markup");\n\t\t\tattr(input9, "type", "checkbox");\n\t\t\tattr(input9, "class", "svelte-1nmrny4");\n\t\t\tattr(pre9, "class", "svelte-1nmrny4");\n\t\t\tattr(li9, "class", "svelte-1nmrny4");\n\t\t\tattr(ul1, "class", "svelte-1nmrny4");\n\t\t\tattr(div1, "class", "item svelte-1nmrny4");\n\t\t\tattr(div2, "class", "grid svelte-1nmrny4");\n\t\t\tattr(main, "class", "svelte-1nmrny4");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, main, anchor);\n\t\t\tappend(main, img);\n\t\t\tappend(main, t0);\n\t\t\tappend(main, h1);\n\t\t\tappend(main, t2);\n\t\t\tappend(main, p);\n\t\t\tappend(main, t4);\n\t\t\tappend(main, div2);\n\t\t\tappend(div2, div0);\n\t\t\tappend(div0, h20);\n\t\t\tappend(div0, t6);\n\t\t\tappend(div0, hr0);\n\t\t\tappend(div0, t7);\n\t\t\tappend(div0, ul0);\n\t\t\tappend(ul0, li0);\n\t\t\tappend(li0, label0);\n\t\t\tappend(li0, t9);\n\t\t\tmount_component(maskedinput0, li0, null);\n\t\t\tappend(li0, t10);\n\t\t\tappend(li0, label1);\n\t\t\tappend(li0, input0);\n\t\t\tappend(li0, t12);\n\t\t\tappend(li0, pre0);\n\t\t\tappend(ul0, t14);\n\t\t\tappend(ul0, li1);\n\t\t\tappend(li1, label2);\n\t\t\tappend(li1, t16);\n\t\t\tmount_component(maskedinput1, li1, null);\n\t\t\tappend(li1, t17);\n\t\t\tappend(li1, label3);\n\t\t\tappend(li1, input1);\n\t\t\tappend(li1, t19);\n\t\t\tappend(li1, pre1);\n\t\t\tappend(pre1, code1);\n\t\t\tappend(ul0, t23);\n\t\t\tappend(ul0, li2);\n\t\t\tappend(li2, label4);\n\t\t\tappend(li2, t25);\n\t\t\tmount_component(maskedinput2, li2, null);\n\t\t\tappend(li2, t26);\n\t\t\tappend(li2, label5);\n\t\t\tappend(li2, input2);\n\t\t\tappend(li2, t28);\n\t\t\tappend(li2, pre2);\n\t\t\tappend(ul0, t30);\n\t\t\tappend(ul0, li3);\n\t\t\tappend(li3, label6);\n\t\t\tappend(li3, t32);\n\t\t\tmount_component(maskedinput3, li3, null);\n\t\t\tappend(li3, t33);\n\t\t\tappend(li3, label7);\n\t\t\tappend(li3, input3);\n\t\t\tappend(li3, t35);\n\t\t\tappend(li3, pre3);\n\t\t\tappend(pre3, code3);\n\t\t\tappend(ul0, t43);\n\t\t\tappend(ul0, li4);\n\t\t\tappend(li4, label8);\n\t\t\tappend(li4, t45);\n\t\t\tmount_component(maskedinput4, li4, null);\n\t\t\tappend(li4, t46);\n\t\t\tappend(li4, label9);\n\t\t\tappend(li4, input4);\n\t\t\tappend(li4, t48);\n\t\t\tappend(li4, pre4);\n\t\t\tappend(pre4, code4);\n\t\t\tappend(div2, t58);\n\t\t\tappend(div2, div1);\n\t\t\tappend(div1, h21);\n\t\t\tappend(div1, t60);\n\t\t\tappend(div1, hr1);\n\t\t\tappend(div1, t61);\n\t\t\tappend(div1, ul1);\n\t\t\tappend(ul1, li5);\n\t\t\tappend(li5, label10);\n\t\t\tappend(li5, t63);\n\t\t\tmount_component(formattedinput0, li5, null);\n\t\t\tappend(li5, t64);\n\t\t\tappend(li5, label11);\n\t\t\tappend(li5, input5);\n\t\t\tappend(li5, t66);\n\t\t\tappend(li5, pre5);\n\t\t\tappend(ul1, t68);\n\t\t\tappend(ul1, li6);\n\t\t\tappend(li6, label12);\n\t\t\tappend(li6, t70);\n\t\t\tmount_component(formattedinput1, li6, null);\n\t\t\tappend(li6, t71);\n\t\t\tappend(li6, label13);\n\t\t\tappend(li6, input6);\n\t\t\tappend(li6, t73);\n\t\t\tappend(li6, pre6);\n\t\t\tappend(ul1, t75);\n\t\t\tappend(ul1, li7);\n\t\t\tappend(li7, label14);\n\t\t\tappend(li7, t77);\n\t\t\tmount_component(formattedinput2, li7, null);\n\t\t\tappend(li7, t78);\n\t\t\tappend(li7, label15);\n\t\t\tappend(li7, input7);\n\t\t\tappend(li7, t80);\n\t\t\tappend(li7, pre7);\n\t\t\tappend(ul1, t82);\n\t\t\tappend(ul1, li8);\n\t\t\tappend(li8, label16);\n\t\t\tappend(li8, t84);\n\t\t\tmount_component(formattedinput3, li8, null);\n\t\t\tappend(li8, t85);\n\t\t\tappend(li8, label17);\n\t\t\tappend(li8, input8);\n\t\t\tappend(li8, t87);\n\t\t\tappend(li8, pre8);\n\t\t\tappend(ul1, t89);\n\t\t\tappend(ul1, li9);\n\t\t\tappend(li9, label18);\n\t\t\tappend(li9, t91);\n\t\t\tmount_component(formattedinput4, li9, null);\n\t\t\tappend(li9, t92);\n\t\t\tappend(li9, label19);\n\t\t\tappend(li9, input9);\n\t\t\tappend(li9, t94);\n\t\t\tappend(li9, pre9);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: noop,\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(maskedinput0.$$.fragment, local);\n\t\t\ttransition_in(maskedinput1.$$.fragment, local);\n\t\t\ttransition_in(maskedinput2.$$.fragment, local);\n\t\t\ttransition_in(maskedinput3.$$.fragment, local);\n\t\t\ttransition_in(maskedinput4.$$.fragment, local);\n\t\t\ttransition_in(formattedinput0.$$.fragment, local);\n\t\t\ttransition_in(formattedinput1.$$.fragment, local);\n\t\t\ttransition_in(formattedinput2.$$.fragment, local);\n\t\t\ttransition_in(formattedinput3.$$.fragment, local);\n\t\t\ttransition_in(formattedinput4.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(maskedinput0.$$.fragment, local);\n\t\t\ttransition_out(maskedinput1.$$.fragment, local);\n\t\t\ttransition_out(maskedinput2.$$.fragment, local);\n\t\t\ttransition_out(maskedinput3.$$.fragment, local);\n\t\t\ttransition_out(maskedinput4.$$.fragment, local);\n\t\t\ttransition_out(formattedinput0.$$.fragment, local);\n\t\t\ttransition_out(formattedinput1.$$.fragment, local);\n\t\t\ttransition_out(formattedinput2.$$.fragment, local);\n\t\t\ttransition_out(formattedinput3.$$.fragment, local);\n\t\t\ttransition_out(formattedinput4.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) detach(main);\n\t\t\tdestroy_component(maskedinput0);\n\t\t\tdestroy_component(maskedinput1);\n\t\t\tdestroy_component(maskedinput2);\n\t\t\tdestroy_component(maskedinput3);\n\t\t\tdestroy_component(maskedinput4);\n\t\t\tdestroy_component(formattedinput0);\n\t\t\tdestroy_component(formattedinput1);\n\t\t\tdestroy_component(formattedinput2);\n\t\t\tdestroy_component(formattedinput3);\n\t\t\tdestroy_component(formattedinput4);\n\t\t}\n\t};\n}\n\nclass App extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, App_svelte_create_fragment, safe_not_equal, {}, App_svelte_add_css);\n\t}\n}\n\n/* harmony default export */ const App_svelte = (App);\n;// CONCATENATED MODULE: ./src/main.js\n\n\nconst app = new App_svelte({\n    props: {\n        name: \'Svelte Masked Input\',\n    },\n    target: document.body,\n});\n\n/* harmony default export */ const main = ((/* unused pure expression or super */ null && (app)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCLEVBQUUsS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0dBQzNHLE1BS0s7O0dBRVQsTUFXSTtHQVZBLE1BQTRDOzs7O0dBRzVDLE1BQW1FO0dBQUEsTUFBZ0Q7O0dBQ25ILE1BS0s7O0dBRVQsTUFXSTtHQVZBLE1BQTJDOzs7O0dBRzNDLE1BQWtFO0dBQUEsTUFBK0M7O0dBQ2pILE1BS0s7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalJNOztBQUUvQixnQkFBZ0IsVUFBRztBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRCwyQ0FBZSxtREFBRyxJQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3ZlbHRlLW1hc2tlZC1pbnB1dC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvaW50ZXJuYWwvaW5kZXgubWpzPzk5YjQiLCJ3ZWJwYWNrOi8vc3ZlbHRlLW1hc2tlZC1pbnB1dC8uL3NyYy9jb21wb25lbnRzL01hc2tlZElucHV0LnN2ZWx0ZT80MWYyIiwid2VicGFjazovL3N2ZWx0ZS1tYXNrZWQtaW5wdXQvLi9zcmMvY29tcG9uZW50cy9Gb3JtYXR0ZWRJbnB1dC5zdmVsdGU/MjcyZSIsIndlYnBhY2s6Ly9zdmVsdGUtbWFza2VkLWlucHV0Ly4vc3JjL0FwcC5zdmVsdGU/NWI4NiIsIndlYnBhY2s6Ly9zdmVsdGUtbWFza2VkLWlucHV0Ly4vc3JjL21haW4uanM/NTZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcbiAgICBlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG4gICAgICAgIGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuICAgIH07XG59XG5mdW5jdGlvbiBydW4oZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG4gICAgZm5zLmZvckVhY2gocnVuKTtcbn1cbmZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcbiAgICBpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG4gICAgICAgIHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cbiAgICBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuICAgIHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cbmZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5mdW5jdGlvbiBpc19lbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuICAgIGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKHN0b3JlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHN1YnNjcmliZShzdG9yZSwgXyA9PiB2YWx1ZSA9IF8pKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuICAgIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuXG4gICAgICAgID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpXG4gICAgICAgIDogJCRzY29wZS5jdHg7XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG4gICAgICAgIGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG4gICAgICAgIGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuICAgIH1cbiAgICByZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGlmIChzbG90X2NoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG4gICAgICAgIHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3Qoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgY29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcbiAgICB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcbiAgICBpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgY29uc3QgZGlydHkgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gJCRzY29wZS5jdHgubGVuZ3RoIC8gMzI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpcnR5W2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdWx0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuICAgIGNvbnN0IHJlc3QgPSB7fTtcbiAgICBrZXlzID0gbmV3IFNldChrZXlzKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChyYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcbiAgICBzdG9yZS5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbmNvbnN0IGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG5vdyA9IGlzX2NsaWVudFxuICAgID8gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xubGV0IHJhZiA9IGlzX2NsaWVudCA/IGNiID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgOiBub29wO1xuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBzZXRfbm93KGZuKSB7XG4gICAgbm93ID0gZm47XG59XG5mdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG4gICAgcmFmID0gZm47XG59XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgICAgIHRhc2suZigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhc2tzLnNpemUgIT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICovXG5mdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcbiAgICB0YXNrcy5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgaWYgKHRhc2tzLnNpemUgPT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bGZpbGwgPT4ge1xuICAgICAgICAgICAgdGFza3MuYWRkKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuICAgIC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgICAgICBpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG59XG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oeWRyYXRlX2luaXQpXG4gICAgICAgIHJldHVybjtcbiAgICB0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcbiAgICAvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG4gICAgbGV0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkTm9kZXM7XG4gICAgLy8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcbiAgICAgICAgY29uc3QgbXlDaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXlDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gbXlDaGlsZHJlbjtcbiAgICB9XG4gICAgLypcbiAgICAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG4gICAgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG4gICAgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuICAgICogc3Vic2VxdWVuY2Ugc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcbiAgICAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG4gICAgKlxuICAgICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG4gICAgKiBwb3NzaWJsZS5cbiAgICAqXG4gICAgKiBQcm9vZjpcbiAgICAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuICAgICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG4gICAgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuICAgICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cbiAgICAqL1xuICAgIC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgLy8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuICAgIGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcbiAgICAvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuICAgIGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuICAgIG1bMF0gPSAtMTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG4gICAgICAgIC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG4gICAgICAgIC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG4gICAgICAgIGNvbnN0IHNlcUxlbiA9ICgobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudCkgPyBsb25nZXN0ICsgMSA6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIGlkeCA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuICAgICAgICBwW2ldID0gbVtzZXFMZW5dICsgMTtcbiAgICAgICAgY29uc3QgbmV3TGVuID0gc2VxTGVuICsgMTtcbiAgICAgICAgLy8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuICAgICAgICBtW25ld0xlbl0gPSBpO1xuICAgICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmV3TGVuLCBsb25nZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuICAgIGNvbnN0IGxpcyA9IFtdO1xuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG4gICAgY29uc3QgdG9Nb3ZlID0gW107XG4gICAgbGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuICAgICAgICBsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG4gICAgICAgIGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG4gICAgICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC0tO1xuICAgIH1cbiAgICBmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcbiAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgIH1cbiAgICBsaXMucmV2ZXJzZSgpO1xuICAgIC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuICAgIHRvTW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG4gICAgLy8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b01vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvTW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUodG9Nb3ZlW2ldLCBhbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuICAgIGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG4gICAgICAgIGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGlmIChyb290ICYmIHJvb3QuaG9zdCkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICBhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuICAgIHJldHVybiBzdHlsZV9lbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcbiAgICBhcHBlbmQobm9kZS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50RWxlbWVudCAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcylcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC5pc1RydXN0ZWQpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yc1trZXldICYmIGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChncm91cFtpXS5jaGVja2VkKVxuICAgICAgICAgICAgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgdmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2Rlcykge1xuICAgIC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuICAgIGNvbnN0IHN0YXJ0X2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcbiAgICBjb25zdCBlbmRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCk7XG4gICAgaWYgKHN0YXJ0X2luZGV4ID09PSBlbmRfaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKCk7XG4gICAgfVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzKTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCAhPT0gZGF0YSlcbiAgICAgICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKSB8fCBzZWxlY3Qub3B0aW9uc1swXTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcbiAgICBjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgY29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcbiAgICAgICAgJ292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOycpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBpZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICBjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4od2luZG93LCAnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmQobm9kZSwgaWZyYW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoKGlmcmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIGJ1YmJsZXMgPSBmYWxzZSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5jbGFzcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICB9XG4gICAgbShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmUpIHtcbiAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuYyhodG1sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkoYW5jaG9yKTtcbiAgICB9XG4gICAgaChodG1sKSB7XG4gICAgICAgIHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sID0gY2xhaW1lZF9ub2RlcztcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIGlmICh0aGlzLmwpIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHRoaXMubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICByZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGFjdGl2ZV9kb2NzID0gbmV3IFNldCgpO1xubGV0IGFjdGl2ZSA9IDA7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgICBsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgICAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIGAleyR7Zm4odCwgMSAtIHQpfX1cXG5gO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcbiAgICBjb25zdCBuYW1lID0gYF9fc3ZlbHRlXyR7aGFzaChydWxlKX1fJHt1aWR9YDtcbiAgICBjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG4gICAgYWN0aXZlX2RvY3MuYWRkKGRvYyk7XG4gICAgY29uc3Qgc3R5bGVzaGVldCA9IGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0IHx8IChkb2MuX19zdmVsdGVfc3R5bGVzaGVldCA9IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLnNoZWV0KTtcbiAgICBjb25zdCBjdXJyZW50X3J1bGVzID0gZG9jLl9fc3ZlbHRlX3J1bGVzIHx8IChkb2MuX19zdmVsdGVfcnVsZXMgPSB7fSk7XG4gICAgaWYgKCFjdXJyZW50X3J1bGVzW25hbWVdKSB7XG4gICAgICAgIGN1cnJlbnRfcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoYEBrZXlmcmFtZXMgJHtuYW1lfSAke3J1bGV9YCwgc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGAke2FuaW1hdGlvbiA/IGAke2FuaW1hdGlvbn0sIGAgOiAnJ30ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcbiAgICBhY3RpdmUgKz0gMTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IChub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihuYW1lXG4gICAgICAgID8gYW5pbSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cbiAgICAgICAgOiBhbmltID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICAgICk7XG4gICAgY29uc3QgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbmV4dC5qb2luKCcsICcpO1xuICAgICAgICBhY3RpdmUgLT0gZGVsZXRlZDtcbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjbGVhcl9ydWxlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFjdGl2ZV9kb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldDtcbiAgICAgICAgICAgIGxldCBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgICAgICAgICAgIGRvYy5fX3N2ZWx0ZV9ydWxlcyA9IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aXZlX2RvY3MuY2xlYXIoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2FuaW1hdGlvbihub2RlLCBmcm9tLCBmbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGZyb20ubGVmdCA9PT0gdG8ubGVmdCAmJiBmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJiBmcm9tLnRvcCA9PT0gdG8udG9wICYmIGZyb20uYm90dG9tID09PSB0by5ib3R0b20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG4gICAgc3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86XG4gICAgZW5kID0gc3RhcnRfdGltZSArIGR1cmF0aW9uLCB0aWNrID0gbm9vcCwgY3NzIH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG5hbWU7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5KSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9vcChub3cgPT4ge1xuICAgICAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBzdGFydCgpO1xuICAgIHRpY2soMCwgMSk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG5mdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcbiAgICAgICAgY29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuICAgIGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhLmxlZnQgIT09IGIubGVmdCB8fCBhLnRvcCAhPT0gYi50b3ApIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7YS5sZWZ0IC0gYi5sZWZ0fXB4LCAke2EudG9wIC0gYi50b3B9cHgpYDtcbiAgICB9XG59XG5cbmxldCBjdXJyZW50X2NvbXBvbmVudDtcbmZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcbiAgICBpZiAoIWN1cnJlbnRfY29tcG9uZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuICAgIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgLy8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5mdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG4gICAgfVxufVxuXG5jb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5jb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5jb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICAgIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrKCkge1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgIHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgY29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICB3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG4gICAgICAgICAgICBmbHVzaGlkeCsrO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoY29tcG9uZW50LiQkKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hpZHggPSAwO1xuICAgICAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH1cbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAkJC51cGRhdGUoKTtcbiAgICAgICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAgICAgY29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcbiAgICAgICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICAgICAkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG59XG5cbmxldCBwcm9taXNlO1xuZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xubGV0IG91dHJvcztcbmZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcbiAgICBvdXRyb3MgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgIGM6IFtdLFxuICAgICAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcbiAgICBpZiAoIW91dHJvcy5yKSB7XG4gICAgICAgIHJ1bl9hbGwob3V0cm9zLmMpO1xuICAgIH1cbiAgICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgYmxvY2suaShsb2NhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICAgICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgICAgIG91dHJvcy5jLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmQoMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2NrLm8obG9jYWwpO1xuICAgIH1cbn1cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbmZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRhc2spXG4gICAgICAgICAgICB0YXNrLmFib3J0KCk7XG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcbiAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuICAgIGdyb3VwLnIgKz0gMTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWdyb3VwLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwoZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSAtIHQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZChyZXNldCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRpY2soMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuICAgIGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZCA9IChwcm9ncmFtLmIgLSB0KTtcbiAgICAgICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiB0LFxuICAgICAgICAgICAgYjogcHJvZ3JhbS5iLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgICAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBub3coKSArIGRlbGF5LFxuICAgICAgICAgICAgYlxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBwcm9ncmFtLmdyb3VwID0gb3V0cm9zO1xuICAgICAgICAgICAgb3V0cm9zLnIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcbiAgICAgICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBydW5uaW5nX3Byb2dyYW0uYiwgcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLCAwLCBlYXNpbmcsIGNvbmZpZy5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQgPSBydW5uaW5nX3Byb2dyYW0uYiwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRybyDigJQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXRybyDigJQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBydW4oYikge1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcbiAgICBjb25zdCB0b2tlbiA9IGluZm8udG9rZW4gPSB7fTtcbiAgICBmdW5jdGlvbiB1cGRhdGUodHlwZSwgaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZm8udG9rZW4gIT09IHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbmZvLnJlc29sdmVkID0gdmFsdWU7XG4gICAgICAgIGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uYmxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBpbmRleCAmJiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ibG9ja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZm8uYmxvY2suZCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICAgICAgYmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcbiAgICAgICAgICAgIG5lZWRzX2ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrcylcbiAgICAgICAgICAgIGluZm8uYmxvY2tzW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICBpZiAobmVlZHNfZmx1c2gpIHtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX3Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICAgICAgaWYgKCFpbmZvLmhhc0NhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby5wZW5kaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby5wZW5kaW5nLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHByb21pc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaChpbmZvLCBjdHgsIGRpcnR5KSB7XG4gICAgY29uc3QgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLnRoZW4pIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8uY2F0Y2gpIHtcbiAgICAgICAgY2hpbGRfY3R4W2luZm8uZXJyb3JdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZCgxKTtcbiAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5mdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gICAgbGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcbiAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpID0gbztcbiAgICBjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gICAgY29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2xvb2t1cC5zZXQoa2V5LCBuZXdfYmxvY2tzW2ldID0gYmxvY2spO1xuICAgICAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKVxuICAgICAgICAgICAgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgIGJsb2NrLm0obm9kZSwgbmV4dCk7XG4gICAgICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgICAgIG5leHQgPSBibG9jay5maXJzdDtcbiAgICAgICAgbi0tO1xuICAgIH1cbiAgICB3aGlsZSAobyAmJiBuKSB7XG4gICAgICAgIGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG4gICAgICAgIGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuICAgICAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGJsb2NrXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuICAgICAgICAgICAgZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcbiAgICAgICAgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSlcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgIH1cbiAgICB3aGlsZSAobilcbiAgICAgICAgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG5jb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnYWxsb3dmdWxsc2NyZWVuJyxcbiAgICAnYWxsb3dwYXltZW50cmVxdWVzdCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXV0b2ZvY3VzJyxcbiAgICAnYXV0b3BsYXknLFxuICAgICdjaGVja2VkJyxcbiAgICAnY29udHJvbHMnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVmZXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2Zvcm1ub3ZhbGlkYXRlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaXNtYXAnLFxuICAgICdsb29wJyxcbiAgICAnbXVsdGlwbGUnLFxuICAgICdtdXRlZCcsXG4gICAgJ25vbW9kdWxlJyxcbiAgICAnbm92YWxpZGF0ZScsXG4gICAgJ29wZW4nLFxuICAgICdwbGF5c2lubGluZScsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXSk7XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuICAgIGlmIChjbGFzc2VzX3RvX2FkZCkge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IGVzY2FwZWQgPSB7XG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnXG59O1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwpIHtcbiAgICByZXR1cm4gU3RyaW5nKGh0bWwpLnJlcGxhY2UoL1tcIicmPD5dL2csIG1hdGNoID0+IGVzY2FwZWRbbWF0Y2hdKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IGVzY2FwZSh2YWx1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1ZyhmaWxlLCBsaW5lLCBjb2x1bW4sIHZhbHVlcykge1xuICAgIGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4gJyc7XG59XG5sZXQgb25fZGVzdHJveTtcbmZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG4gICAgZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICAgICAgY29uc3QgJCQgPSB7XG4gICAgICAgICAgICBvbl9kZXN0cm95LFxuICAgICAgICAgICAgY29udGV4dDogbmV3IE1hcChjb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzY2FyZGVkXG4gICAgICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuICAgICAgICBjb25zdCBodG1sID0gZm4ocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzKTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBvbl9kZXN0cm95ID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVuX2FsbChvbl9kZXN0cm95KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQXJyYXkuZnJvbShyZXN1bHQuY3NzKS5tYXAoY3NzID0+IGNzcy5jb2RlKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAkJHJlbmRlclxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGJvb2xlYW4gJiYgIXZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHJldHVybiBgICR7bmFtZX0ke3ZhbHVlID09PSB0cnVlID8gJycgOiBgPSR7dHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KGVzY2FwZSh2YWx1ZSkpIDogYFwiJHt2YWx1ZX1cImB9YH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cblxuZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICAgIGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG4gICAgYmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IsIGN1c3RvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50LCBvbl9tb3VudCwgb25fZGVzdHJveSwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIG9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgYXBwZW5kX3N0eWxlcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBudWxsLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuNDQuMycgfSwgZGV0YWlsKSwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24pIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBvcHRpb25zID09PSB0cnVlID8gWydjYXB0dXJlJ10gOiBvcHRpb25zID8gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvcHRpb25zKSkgOiBbXTtcbiAgICBpZiAoaGFzX3ByZXZlbnRfZGVmYXVsdClcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3ByZXZlbnREZWZhdWx0Jyk7XG4gICAgaWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpKSB7XG4gICAgICAgIGxldCBtc2cgPSAneyNlYWNofSBvbmx5IGl0ZXJhdGVzIG92ZXIgYXJyYXktbGlrZSBvYmplY3RzLic7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKSB7XG4gICAgICAgICAgICBtc2cgKz0gJyBZb3UgY2FuIHVzZSBhIHNwcmVhZCB0byBjb252ZXJ0IHRoaXMgaXRlcmFibGUgaW50byBhbiBhcnJheS4nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG4gICAgICAgIGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzIHdpdGggc29tZSBtaW5vciBkZXYtZW5oYW5jZW1lbnRzLiBVc2VkIHdoZW4gZGV2PXRydWUuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudERldiBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb21wb25lbnQgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAkY2FwdHVyZV9zdGF0ZSgpIHsgfVxuICAgICRpbmplY3Rfc3RhdGUoKSB7IH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKiBUaGlzIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXMgYW5kIHNob3VsZCBiZSB1c2VkIGluIGAuZC50c2AgZmlsZXMuXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogWW91IGhhdmUgY29tcG9uZW50IGxpYnJhcnkgb24gbnBtIGNhbGxlZCBgY29tcG9uZW50LWxpYnJhcnlgLCBmcm9tIHdoaWNoXG4gKiB5b3UgZXhwb3J0IGEgY29tcG9uZW50IGNhbGxlZCBgTXlDb21wb25lbnRgLiBGb3IgU3ZlbHRlK1R5cGVTY3JpcHQgdXNlcnMsXG4gKiB5b3Ugd2FudCB0byBwcm92aWRlIHR5cGluZ3MuIFRoZXJlZm9yZSB5b3UgY3JlYXRlIGEgYGluZGV4LmQudHNgOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudFR5cGVkIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50VHlwZWQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICpcbiAqICMjIyMgV2h5IG5vdCBtYWtlIHRoaXMgcGFydCBvZiBgU3ZlbHRlQ29tcG9uZW50KERldilgP1xuICogQmVjYXVzZVxuICogYGBgdHNcbiAqIGNsYXNzIEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50PHtmb286IHN0cmluZ30+IHt9XG4gKiBjb25zdCBjb21wb25lbnQ6IHR5cGVvZiBTdmVsdGVDb21wb25lbnQgPSBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudDtcbiAqIGBgYFxuICogd2lsbCB0aHJvdyBhIHR5cGUgZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlIG1vcmUgc3RyaWN0bHkgdHlwZWQgY2xhc3MuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkIGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50RGV2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvb3BfZ3VhcmQodGltZW91dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgeyBIdG1sVGFnLCBIdG1sVGFnSHlkcmF0aW9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3Jlc2l6ZV9saXN0ZW5lciwgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGFwcGVuZF9oeWRyYXRpb24sIGFwcGVuZF9oeWRyYXRpb25fZGV2LCBhcHBlbmRfc3R5bGVzLCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9odG1sX3RhZywgY2xhaW1fc3BhY2UsIGNsYWltX3N2Z19lbGVtZW50LCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjb21wdXRlX3Nsb3RzLCBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGNyZWF0ZV9hbmltYXRpb24sIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24sIGNyZWF0ZV9jb21wb25lbnQsIGNyZWF0ZV9pbl90cmFuc2l0aW9uLCBjcmVhdGVfb3V0X3RyYW5zaXRpb24sIGNyZWF0ZV9zbG90LCBjcmVhdGVfc3NyX2NvbXBvbmVudCwgY3VycmVudF9jb21wb25lbnQsIGN1c3RvbV9ldmVudCwgZGF0YXNldF9kZXYsIGRlYnVnLCBkZXN0cm95X2Jsb2NrLCBkZXN0cm95X2NvbXBvbmVudCwgZGVzdHJveV9lYWNoLCBkZXRhY2gsIGRldGFjaF9hZnRlcl9kZXYsIGRldGFjaF9iZWZvcmVfZGV2LCBkZXRhY2hfYmV0d2Vlbl9kZXYsIGRldGFjaF9kZXYsIGRpcnR5X2NvbXBvbmVudHMsIGRpc3BhdGNoX2RldiwgZWFjaCwgZWxlbWVudCwgZWxlbWVudF9pcywgZW1wdHksIGVuZF9oeWRyYXRpbmcsIGVzY2FwZSwgZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSwgZXNjYXBlX29iamVjdCwgZXNjYXBlZCwgZXhjbHVkZV9pbnRlcm5hbF9wcm9wcywgZml4X2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfcG9zaXRpb24sIGZsdXNoLCBnZXRBbGxDb250ZXh0cywgZ2V0Q29udGV4dCwgZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlLCBnZXRfYmluZGluZ19ncm91cF92YWx1ZSwgZ2V0X2N1cnJlbnRfY29tcG9uZW50LCBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLCBnZXRfcm9vdF9mb3Jfc3R5bGUsIGdldF9zbG90X2NoYW5nZXMsIGdldF9zcHJlYWRfb2JqZWN0LCBnZXRfc3ByZWFkX3VwZGF0ZSwgZ2V0X3N0b3JlX3ZhbHVlLCBnbG9iYWxzLCBncm91cF9vdXRyb3MsIGhhbmRsZV9wcm9taXNlLCBoYXNDb250ZXh0LCBoYXNfcHJvcCwgaWRlbnRpdHksIGluaXQsIGluc2VydCwgaW5zZXJ0X2RldiwgaW5zZXJ0X2h5ZHJhdGlvbiwgaW5zZXJ0X2h5ZHJhdGlvbl9kZXYsIGludHJvcywgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIsIGlzX2NsaWVudCwgaXNfY3Jvc3NvcmlnaW4sIGlzX2VtcHR5LCBpc19mdW5jdGlvbiwgaXNfcHJvbWlzZSwgbGlzdGVuLCBsaXN0ZW5fZGV2LCBsb29wLCBsb29wX2d1YXJkLCBtaXNzaW5nX2NvbXBvbmVudCwgbW91bnRfY29tcG9uZW50LCBub29wLCBub3RfZXF1YWwsIG5vdywgbnVsbF90b19lbXB0eSwgb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcywgb25EZXN0cm95LCBvbk1vdW50LCBvbmNlLCBvdXRyb19hbmRfZGVzdHJveV9ibG9jaywgcHJldmVudF9kZWZhdWx0LCBwcm9wX2RldiwgcXVlcnlfc2VsZWN0b3JfYWxsLCByYWYsIHJ1biwgcnVuX2FsbCwgc2FmZV9ub3RfZXF1YWwsIHNjaGVkdWxlX3VwZGF0ZSwgc2VsZWN0X211bHRpcGxlX3ZhbHVlLCBzZWxlY3Rfb3B0aW9uLCBzZWxlY3Rfb3B0aW9ucywgc2VsZWN0X3ZhbHVlLCBzZWxmLCBzZXRDb250ZXh0LCBzZXRfYXR0cmlidXRlcywgc2V0X2N1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YSwgc2V0X2RhdGEsIHNldF9kYXRhX2Rldiwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwcmVhZCwgc3JjX3VybF9lcXVhbCwgc3RhcnRfaHlkcmF0aW5nLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZWFjaF9hcmd1bWVudCwgdmFsaWRhdGVfZWFjaF9rZXlzLCB2YWxpZGF0ZV9zbG90cywgdmFsaWRhdGVfc3RvcmUsIHhsaW5rX2F0dHIgfTtcbiIsIjxzY3JpcHQgbGFuZz1cInR5cGVzY3JpcHRcIj5cbiAgICBleHBvcnQgbGV0IGxldHRlciA9ICdfJztcbiAgICBleHBvcnQgbGV0IG51bWJlciA9ICdYZERtTXlZOSc7XG4gICAgZXhwb3J0IGxldCBwbGFjZWhvbGRlciA9ICcnO1xuICAgIGV4cG9ydCBsZXQgdmFsaWRFeGFtcGxlID0gJyc7XG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9ICcnO1xuICAgIGV4cG9ydCBsZXQgY2hhcnNldDogc3RyaW5nID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IHBhdHRlcm4gPSAnJztcbiAgICBleHBvcnQgbGV0IHByZWZpeCA9ICcnO1xuICAgIGV4cG9ydCBsZXQgcmVxdWlyZWQgPSBmYWxzZTtcblxuICAgIGxldCByYXdWYWx1ZSA9ICcnO1xuICAgIGxldCBpbnB1dEVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgbGV0IGN1cnJlbnRQYXR0ZXJuID0gbnVsbDtcbiAgICBsZXQgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyO1xuXG4gICAgJDogdmFsdWUgPSBjaGFyc2V0ID8gcmF3VmFsdWUucmVwbGFjZSgvXFxXL2csICcnKSA6IHJhd1ZhbHVlLnJlcGxhY2UoL1teXFxkLi1dL2csICcnKTtcbiAgICAkOiBwcmVmaXggPSAocHJlZml4IHx8ICcnKTtcbiAgICAkOiByYXdWYWx1ZSA9IHByZWZpeCAmJiAhcmF3VmFsdWUgPyAnICcgOiByYXdWYWx1ZTtcbiAgICAkOiBoaWRkZW5WYWx1ZSA9IHByZWZpeCAmJiByYXdWYWx1ZSA9PT0gJyAnID8gJycgOiByYXdWYWx1ZTtcbiAgICAkOiByZW1haW5pbmdNYXNrID0gcHJlZml4ID8gcGxhY2Vob2xkZXIucmVwbGFjZShwcmVmaXgsICcnKSA6IHBsYWNlaG9sZGVyO1xuICAgICQ6IHVzZWRQYXR0ZXJuID0gcmVxdWlyZWQgfHwgdmFsdWUgPyBwYXR0ZXJuIDogbnVsbDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgICAgICBjb25zdCBjdXJzb3JQb3NCZWZvcmUgPSBpbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBjdXJzb3JQb3NBZnRlcjtcbiAgICAgICAgcmF3VmFsdWUgPSBpbnB1dEVsZW1lbnQudmFsdWU7XG4gICAgICAgIHZhbHVlID0gY2hhcnNldCA/IHJhd1ZhbHVlLnJlcGxhY2UoL1xcVy9nLCAnJykgOiByYXdWYWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgICAgIGN1cnJlbnRQYXR0ZXJuID0gbnVsbDtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGN1cnNvclBvc0FmdGVyID0gaW5wdXRFbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgICAgIHVwZGF0ZU1hc2soKTtcbiAgICAgICAgY3VycmVudFBhdHRlcm4gPSB1c2VkUGF0dGVybjtcblxuICAgICAgICBpZiAoY3Vyc29yUG9zQWZ0ZXIgLSBjdXJzb3JQb3NCZWZvcmUgPiAxICkge1xuICAgICAgICAgICAgaW5wdXRFbGVtZW50LnNlbGVjdGlvblN0YXJ0ID0gY3Vyc29yUG9zQmVmb3JlO1xuICAgICAgICAgICAgaW5wdXRFbGVtZW50LnNlbGVjdGlvbkVuZCA9IGN1cnNvclBvc0JlZm9yZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hc2soKTogdm9pZCB7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9ICcnO1xuXG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHBsYWNlaG9sZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpc0ludCA9ICFOdW1iZXIuaXNOYU4ocGFyc2VJbnQoc3RyaXBwZWRWYWx1ZVtqXSwgMTApKTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGV0dGVyID0gc3RyaXBwZWRWYWx1ZVtqXSA/IHN0cmlwcGVkVmFsdWVbal0ubWF0Y2goL1tBLVpdL2kpIDogZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzTnVtYmVyID0gbnVtYmVyLmluZGV4T2YocGxhY2Vob2xkZXJbaV0pID49IDA7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzTGV0dGVyID0gbGV0dGVyLmluZGV4T2YocGxhY2Vob2xkZXJbaV0pID49IDA7XG5cbiAgICAgICAgICAgIGlmICgobWF0Y2hlc051bWJlciAmJiBpc0ludCkgfHwgKGNoYXJzZXQgJiYgbWF0Y2hlc0xldHRlciAmJiBpc0xldHRlcikpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSArPSBzdHJpcHBlZFZhbHVlW2orK107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICghY2hhcnNldCAmJiAhaXNJbnQgJiYgbWF0Y2hlc051bWJlcilcbiAgICAgICAgICAgICAgICB8fCAoY2hhcnNldCAmJiAoKG1hdGNoZXNMZXR0ZXIgJiYgIWlzTGV0dGVyKSB8fCAobWF0Y2hlc051bWJlciAmJiAhaXNJbnQpKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgQ2hhcmFjdGVyJyk7XG4gICAgICAgICAgICAgICAgcmF3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgKz0gcGxhY2Vob2xkZXJbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJyZWFrIGlmIG5vIGNoYXJhY3RlcnMgbGVmdCBhbmQgdGhlIHBhdHRlcm4gaXMgbm9uLXNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICBpZiAoc3RyaXBwZWRWYWx1ZVtqXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWRFeGFtcGxlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbGlkYXRlUHJvZ3Jlc3MobmV3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmF3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyLnN1YnN0cmluZyhyYXdWYWx1ZS5sZW5ndGgpO1xuICAgICAgICBjdXJyZW50UGF0dGVybiA9IHVzZWRQYXR0ZXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3Jlc3MobmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IHRlc3RWYWx1ZSA9ICcnO1xuICAgICAgICBjb25zdCBwYXR0ZXJuUmVnRXggPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gbW9udGhzXG4gICAgICAgIGlmIChuZXdWYWx1ZS5sZW5ndGggPT09IDEgJiYgcGxhY2Vob2xkZXIudG9VcHBlckNhc2UoKS5zdWJzdHJpbmcoMCwgMikgPT09ICdNTScpIHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA+IDEgJiYgbmV3VmFsdWUgPCAxMCkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gYDAke25ld1ZhbHVlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXN0IHRoZSB2YWx1ZSwgcmVtb3ZpbmcgdGhlIGxhc3QgY2hhcmFjdGVyLCB1bnRpbCB3aGF0IHlvdSBoYXZlIGlzIGEgc3VibWF0Y2hcbiAgICAgICAgZm9yIChsZXQgaSA9IG5ld1ZhbHVlLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRlc3RWYWx1ZSA9IG5ld1ZhbHVlICsgdmFsaWRFeGFtcGxlLnN1YnN0cmluZyhuZXdWYWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAocGF0dGVyblJlZ0V4LnRlc3QodGVzdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zdWJzdHJpbmcoMCwgbmV3VmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAgIDppbnZhbGlkIHtcbiAgICAgICAgb3V0bGluZTogMXB4IHNvbGlkIHJlZDtcbiAgICB9XG5cbiAgICAuc2hlbGwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgIH1cblxuICAgIC5zaGVsbCBzcGFuIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgbGVmdDogNHB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgICAgIGNvbG9yOiAjY2NjO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgei1pbmRleDogLTE7XG4gICAgfVxuICAgIC5zaGVsbCBzcGFuIGkge1xuICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIH1cblxuICAgIGlucHV0Lm1hc2tlZCxcbiAgICAuc2hlbGwgc3BhbiB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgfVxuPC9zdHlsZT5cbjxzcGFuIGNsYXNzPVwic2hlbGxcIj5cblx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3ZhbHVlLmxlbmd0aCA/ICcnIDogcHJlZml4fTxpPntoaWRkZW5WYWx1ZX08L2k+e3JlbWFpbmluZ01hc2t9PC9zcGFuPlxuXHQ8aW5wdXRcbiAgICAgICAgYmluZDp0aGlzPXtpbnB1dEVsZW1lbnR9XG4gICAgICAgIGNsYXNzPVwibWFza2VkXCJcbiAgICAgICAgcGF0dGVybj17Y3VycmVudFBhdHRlcm59XG4gICAgICAgIHZhbHVlPXtyYXdWYWx1ZX1cbiAgICAgICAgb246a2V5dXA9e3VwZGF0ZX1cbiAgICAgICAgbWF4bGVuZ3RoPXtwbGFjZWhvbGRlci5sZW5ndGh9XG4gICAgICAgIHsuLi4kJHJlc3RQcm9wc31cblx0Lz5cbjwvc3Bhbj5cbiIsIjxzY3JpcHQgbGFuZz1cInR5cGVzY3JpcHRcIj5cbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gJyc7XG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9ICcnO1xuICAgIGV4cG9ydCBsZXQgcGF0dGVybiA9ICcnO1xuICAgIGV4cG9ydCBsZXQgZm9ybWF0ID0gJyc7XG4gICAgZXhwb3J0IGxldCBwcmVmaXggPSAnJztcbiAgICBleHBvcnQgbGV0IHJlcXVpcmVkID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBmb3JtYXR0ZXIgPSBudWxsO1xuICAgIGV4cG9ydCBsZXQgbG9jYWxlID0gJ2VuLXVzJztcbiAgICBleHBvcnQgbGV0IGN1cnJlbmN5ID0gJ1VTRCc7XG4gICAgZXhwb3J0IGxldCBmb3JtYXRPcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCBzdHJpbmc+ID0gbnVsbDtcblxuICAgIGxldCByYXdWYWx1ZSA9ICcnO1xuICAgIGxldCBpbnB1dEVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgbGV0IGN1cnJlbnRQYXR0ZXJuID0gbnVsbDtcbiAgICBsZXQgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyO1xuICAgIGxldCBzaWduaWZpY2FudERpZ2l0cyA9IDE7XG4gICAgbGV0IGRlY2ltYWxSZWdFeHA6IFJlZ0V4cCA9IG51bGw7XG4gICAgbGV0IGRlY2ltYWxFbmRSZWdFeHA6IFJlZ0V4cCA9IG51bGw7XG4gICAgbGV0IHNlcGVyYXRvcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIGNvbnN0IGxvZzEwID0gTWF0aC5sb2coMTApO1xuXG4gICAgZnVuY3Rpb24gZ2V0U2VwZXJhdG9ycyhfKSB7XG4gICAgICAgIGNvbnN0IG51bWJlcldpdGhHcm91cEFuZERlY2ltYWxTZXBhcmF0b3IgPSAxMDAwLjE7XG4gICAgICAgIHJldHVybiBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUpXG4gICAgICAgICAgICAuZm9ybWF0VG9QYXJ0cyhudW1iZXJXaXRoR3JvdXBBbmREZWNpbWFsU2VwYXJhdG9yKVxuICAgICAgICAgICAgLnJlZHVjZSgoY29sbGVjdGlvbiwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdkZWNpbWFsJyB8fCBwYXJ0LnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltwYXJ0LnR5cGVdID0gcGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICAkOiBzZXBlcmF0b3JzID0gZ2V0U2VwZXJhdG9ycyhsb2NhbGUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U2lnbmlmaWNhbnREaWdpdENvdW50KG4pIHtcbiAgICAgICAgbiA9IE1hdGguYWJzKHBhcnNlRmxvYXQoU3RyaW5nKG4pLnJlcGxhY2Uoc2VwZXJhdG9ycy5kZWNpbWFsLCAnJykpKTtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobiAhPT0gMCAmJiBuICUgMTAgPT09IDApIHtcbiAgICAgICAgICAgIG4gLz0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZyhuKSAvIGxvZzEwKSArIDE7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0cyA9IHtcbiAgICAgICAgY3VycmVuY3koaW5wdXQpOiBzdHJpbmcge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RnVuY3Rpb24gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb24uZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVuY3lJbnQoaW5wdXQpOiBzdHJpbmcge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RnVuY3Rpb24gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAwLFxuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb24uZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW50KGlucHV0KTogc3RyaW5nIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdEZ1bmN0aW9uID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwge1xuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICAgICAgICAgICAgc3R5bGU6ICdkZWNpbWFsJyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb24uZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyKGlucHV0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RnVuY3Rpb24gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICAgICAgbWluaW11bVNpZ25pZmljYW50RGlnaXRzOiBzaWduaWZpY2FudERpZ2l0cyxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2RlY2ltYWwnLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbi5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICBwZXJjZW50KGlucHV0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RnVuY3Rpb24gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAwLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAncGVyY2VudCcsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uLmZvcm1hdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBlcmNlbnRJbnQoaW5wdXQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRGdW5jdGlvbiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdE9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAncGVyY2VudCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbi5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JtYXREZWNpbWFscyhjdXJyZW50Rm9ybWF0dGVyKSB7XG4gICAgICAgIGNvbnN0IGlzRGVjaW1hbCA9IGRlY2ltYWxFbmRSZWdFeHAudGVzdChpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICBjb25zdCBoYXNEZWNpbWFsID0gZGVjaW1hbFJlZ0V4cC50ZXN0KGlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHVzZWRWYWx1ZSA9IGlzRGVjaW1hbCA/IHZhbHVlLnNsaWNlKDAsIC0xKSA6IHZhbHVlO1xuICAgICAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlRmxvYXQodXNlZFZhbHVlKTtcbiAgICAgICAgY29uc3QgZGlnaXRzID0gaW50VmFsdWUgPiAwXG4gICAgICAgICAgICA/IGdldFNpZ25pZmljYW50RGlnaXRDb3VudCh2YWx1ZSkgKyAxXG4gICAgICAgICAgICA6IE1hdGgubWluKDQsIGhhc0RlY2ltYWwgPyB2YWx1ZS5sZW5ndGggLSAxIDogdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGludFZhbHVlKSkge1xuICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtYWluaW5nTWFzayA9IGAke2lzRGVjaW1hbCA/ICcnIDogc2VwZXJhdG9ycy5kZWNpbWFsfSR7cGxhY2Vob2xkZXJEZWNpbWFsfWA7XG4gICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gIS8wJC8udGVzdChyYXdWYWx1ZSkgPyB1bmRlZmluZWQgOiBkaWdpdHM7XG5cbiAgICAgICAgaWYgKGhhc0RlY2ltYWwgJiYgIWlzRGVjaW1hbCkge1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbExlbmd0aCA9IHJhd1ZhbHVlLnNwbGl0KHNlcGVyYXRvcnMuZGVjaW1hbClbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVjaW1hbHMgPSBwbGFjZWhvbGRlckRlY2ltYWxMZW5ndGggLSBkZWNpbWFsTGVuZ3RoO1xuXG4gICAgICAgICAgICByZW1haW5pbmdNYXNrID0gYCR7cmVtYWluaW5nRGVjaW1hbHMgPiAwID8gcGxhY2Vob2xkZXJEZWNpbWFsLnNsaWNlKC0xICogZGVjaW1hbExlbmd0aCkgOiAnJ31gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke2N1cnJlbnRGb3JtYXR0ZXIoaW50VmFsdWUpfSR7aXNEZWNpbWFsID8gc2VwZXJhdG9ycy5kZWNpbWFsIDogJyd9YDtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXR0ZXJzID0ge1xuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgZm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXREZWNpbWFscyhmb3JtYXRzLmN1cnJlbmN5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAnXFxcXCRbMC05XXsxLDN9KCxbMC05XXszfSl7MCx9JyxcbiAgICAgICAgICAgIHByZWZpeDogJyQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIGN1cnJlbmN5SW50OiB7XG4gICAgICAgICAgICBmb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocGxhY2Vob2xkZXIubGVuZ3RoIDw9IHJhd1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdNYXNrID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nTWFza0xlbmd0aCA9IHBsYWNlaG9sZGVyLmxlbmd0aCAtIHJhd1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyLnNsaWNlKC0xICogcmVtYWluaW5nTWFza0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRzLmN1cnJlbmN5SW50KGludFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAnXFxcXCRbMC05XXsxLDN9KCxbMC05XXszfSl7MCx9JyxcbiAgICAgICAgICAgIHByZWZpeDogJyQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIGludDoge1xuICAgICAgICAgICAgZm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGludFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHBsYWNlaG9sZGVyLmxlbmd0aCA8PSByYXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ01hc2tMZW5ndGggPSBwbGFjZWhvbGRlci5sZW5ndGggLSByYXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ01hc2sgPSBwbGFjZWhvbGRlci5zbGljZSgtMSAqIHJlbWFpbmluZ01hc2tMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0cy5pbnQoaW50VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46ICdbMC05XXsxLDN9KCxbMC05XXszfSkqXFxcXC5bMC05XScsXG5cbiAgICAgICAgfSxcblxuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0RGVjaW1hbHMoZm9ybWF0cy5udW1iZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46ICdbMC05XXsxLDN9KCxbMC05XXszfSkqKFxcXFwuWzAtOV0rKT8kJyxcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50SW50OiB7XG4gICAgICAgICAgICBmb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocGxhY2Vob2xkZXIubGVuZ3RoIDw9IHJhd1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdNYXNrID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nTWFza0xlbmd0aCA9IHBsYWNlaG9sZGVyLmxlbmd0aCAtIHJhd1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyLnNsaWNlKC0xICogcmVtYWluaW5nTWFza0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHMuaW50KGludFZhbHVlKX1gO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1ZmZpeDogJyUnLFxuICAgICAgICAgICAgcGF0dGVybjogJ1swLTldezEsfSklJyxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFsdWUgPSByYXdWYWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgcmF3VmFsdWUgPSBwcmVmaXggJiYgIXJhd1ZhbHVlID8gJyAnIDogcmF3VmFsdWU7XG4gICAgcmVtYWluaW5nTWFzayA9IHByZWZpeCA/IHBsYWNlaG9sZGVyLnJlcGxhY2UocHJlZml4LCAnJykgOiBwbGFjZWhvbGRlcjtcbiAgICAkOiBmb3JtYXR0ZXIgfHw9IGZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAkOiBwcmVmaXggPSBmb3JtYXQgPyAoZm9ybWF0dGVyc1tmb3JtYXRdLnByZWZpeCB8fCAnJykgOiAocHJlZml4IHx8ICcnKTtcbiAgICAkOiBzdWZmaXggPSBmb3JtYXQgPyAoZm9ybWF0dGVyc1tmb3JtYXRdLnN1ZmZpeCB8fCAnJykgOiAoc3VmZml4IHx8ICcnKTtcbiAgICAkOiBoaWRkZW5WYWx1ZSA9IHByZWZpeCAmJiByYXdWYWx1ZSA9PT0gJyAnID8gJycgOiByYXdWYWx1ZTtcbiAgICAkOiBkZWNpbWFsRW5kUmVnRXhwID0gbmV3IFJlZ0V4cChgXFxcXCR7c2VwZXJhdG9ycy5kZWNpbWFsfSRgKTtcbiAgICAkOiBkZWNpbWFsUmVnRXhwID0gbmV3IFJlZ0V4cChgXFxcXCR7c2VwZXJhdG9ycy5kZWNpbWFsfWApO1xuICAgICQ6IHBsYWNlaG9sZGVyRGVjaW1hbCA9IHBsYWNlaG9sZGVyPy5zcGxpdChzZXBlcmF0b3JzLmRlY2ltYWwpWzFdO1xuICAgICQ6IHBsYWNlaG9sZGVyRGVjaW1hbExlbmd0aCA9IHBsYWNlaG9sZGVyRGVjaW1hbD8ubGVuZ3RoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICB2YWx1ZSA9IGlucHV0RWxlbWVudC52YWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgICAgIGN1cnJlbnRQYXR0ZXJuID0gbnVsbDtcblxuICAgICAgICByYXdWYWx1ZSA9IGZvcm1hdHRlcnNbZm9ybWF0XS5mb3JtYXQoKTtcblxuICAgICAgICBjdXJyZW50UGF0dGVybiA9IHVzZWRQYXR0ZXJuO1xuICAgIH1cblxuICAgICQ6IHVzZWRQYXR0ZXJuID0gcmVxdWlyZWQgfHwgdmFsdWUgPyAoZm9ybWF0ID8gcGF0dGVybiB8fCBmb3JtYXR0ZXJzW2Zvcm1hdF0ucGF0dGVybiA6IHBhdHRlcm4pIDogbnVsbDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbiAgICA6aW52YWxpZCB7XG4gICAgICAgIG91dGxpbmU6IDFweCBzb2xpZCByZWQ7XG4gICAgfVxuXG4gICAgLnNoZWxsIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsaW5lLWhlaWdodDogMTtcbiAgICB9XG5cbiAgICAuc2hlbGwgPiBzcGFuIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgbGVmdDogNHB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgICAgIGNvbG9yOiAjY2NjO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgei1pbmRleDogLTE7XG4gICAgfVxuICAgIC5zaGVsbCBzcGFuIGkge1xuICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIH1cblxuICAgIGlucHV0Lm1hc2tlZCxcbiAgICAuc2hlbGwgPiBzcGFuIHtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAxMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICB9XG5cbiAgICAuc3VmZml4IHtcbiAgICAgICAgY29sb3I6IGluaXRpYWw7XG4gICAgfVxuPC9zdHlsZT5cbjxzcGFuIGNsYXNzPVwic2hlbGxcIj5cblx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3ZhbHVlLmxlbmd0aCA/ICcnIDogcHJlZml4fTxpPntoaWRkZW5WYWx1ZX08L2k+e3JlbWFpbmluZ01hc2t9PHNwYW4gY2xhc3M9XCJzdWZmaXhcIj57c3VmZml4fTwvc3Bhbj48L3NwYW4+XG5cdDxpbnB1dFxuICAgICAgICBiaW5kOnRoaXM9e2lucHV0RWxlbWVudH1cbiAgICAgICAgY2xhc3M9XCJtYXNrZWRcIlxuICAgICAgICBwYXR0ZXJuPXtjdXJyZW50UGF0dGVybn1cbiAgICAgICAgdmFsdWU9e3Jhd1ZhbHVlfVxuICAgICAgICBvbjppbnB1dD17dXBkYXRlfVxuICAgICAgICB7Li4uJCRyZXN0UHJvcHN9XG5cdC8+XG48L3NwYW4+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0eXBlc2NyaXB0XCI+XG5cdGltcG9ydCBNYXNrZWRJbnB1dCBmcm9tICcuL2NvbXBvbmVudHMvTWFza2VkSW5wdXQuc3ZlbHRlJztcbiAgICBpbXBvcnQgRm9ybWF0dGVkSW5wdXQgZnJvbSAnLi9jb21wb25lbnRzL0Zvcm1hdHRlZElucHV0LnN2ZWx0ZSc7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4gICAgKiB7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuXHRtYWluIHtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0cGFkZGluZzogMWVtO1xuXHRcdG1hcmdpbjogMCBhdXRvO1xuXHR9XG5cdGgxIHtcblx0XHRjb2xvcjogI2ZmM2UwMDtcblx0XHRmb250LXNpemU6IDRlbTtcblx0XHRmb250LXdlaWdodDogOTAwO1xuXHR9XG4gICAgaDIge1xuICAgICAgICBmb250LXNpemU6IDIuNWVtO1xuICAgIH1cbiAgICBoMSxoMiB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnQ3V0aXZlIE1vbm8nLCBtb25vc3BhY2U7XG4gICAgfVxuICAgIDpnbG9iYWwoYm9keSAqKSB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnQ3V0aXZlIE1vbm8nLCBtb25vc3BhY2UgIWltcG9ydGFudDtcbiAgICB9XG4gICAgOmdsb2JhbChib2R5IHApIHtcbiAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnTm90byBTYW5zIEpQJywgc2Fucy1zZXJpZiAhaW1wb3J0YW50O1xuICAgIH1cblx0QG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XG5cdFx0bWFpbiB7XG5cdFx0XHRtYXgtd2lkdGg6IG5vbmU7XG5cdFx0fVxuXHR9XG4gICAgLmdyaWQge1xuICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcblxuICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcbiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjtcblx0ICAgIH1cbiAgICB9XG5cbiAgICBsaSA+IGxhYmVsOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgZm9udC1zaXplOiAxLjI1cmVtO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgZm9udC1mYW1pbHk6ICdOb3RvIFNlcmlmIEpQJywgc2VyaWYgIWltcG9ydGFudDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xuICAgIH1cblxuICAgIC5pdGVtIHtcbiAgICAgICAgbWFyZ2luOiAycmVtO1xuICAgIH1cblxuICAgIGltZyB7XG4gICAgICAgIHdpZHRoOiA0MDBweDtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgfVxuXG4gICAgOmdsb2JhbChpbnB1dCksIDpnbG9iYWwoLnNoZWxsIHNwYW4pIHtcbiAgICAgICAgcGFkZGluZzogMC4yNXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XG4gICAgfVxuXG4gICAgcHJlIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZDogYmxhY2s7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgcGFkZGluZzogMXJlbTtcbiAgICAgICAgYm9yZGVyOiA0cHggaW5zZXQgcmVkO1xuICAgIH1cblxuICAgIGlucHV0OmNoZWNrZWQgKyBwcmUge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG5cbiAgICAudG9nZ2xlIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQ7XG4gICAgICAgIHBhZGRpbmc6IDAuMjVyZW07XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA5MDA7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICNlZWU7XG4gICAgICAgIH1cblxuICAgICAgICAmOmFjdGl2ZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMzMzO1xuICAgICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuXG48bWFpbj5cbiAgICA8aW1nIHNyYz1cIi9tYXNrZWQtaW5wdXQtbG9nby5zdmdcIiBhbHQ9XCJsb2dvXCIgLz5cblx0PGgxPlN2ZWx0ZSBNYXNrZWQgSW5wdXQ8L2gxPlxuICAgIDxwPkN5YmVybmV0aWNhbGx5IEVuaGFuY2VkIElucHV0cyB3aXRoIE1hc2tzIGZvciBTdmVsdGUgQXBwczwvcD5cbiAgICA8ZGl2IGNsYXNzPVwiZ3JpZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbVwiPlxuICAgICAgICAgICAgPGgyPk1hc2tlZCBJbnB1dHM8L2gyPlxuICAgICAgICAgICAgPGhyPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImNjLWV4cFwiPkNyZWRpdCBDYXJkIEV4cGlyYXRpb24gTW9udGg8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8TWFza2VkSW5wdXQgaWQ9XCJjYy1leHBcIiB0eXBlPVwidGVsXCIgcGxhY2Vob2xkZXI9XCJNTS9ZWVwiIHBhdHRlcm49XCIoMVswLTJdfDBbMS05XSlcXC9cXGRcXGRcIiB2YWxpZEV4YW1wbGU9XCIxMS8xOFwiIHRpdGxlPVwiMi1kaWdpdCBtb250aCBhbmQgMi1kaWdpdCB5ZWFyIGdyZWF0ZXIgdGhhbiAwMS8xNVwiIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlXCIgZm9yPVwiY2MtZXhwLW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJjYy1leHAtbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwiY2MtZXhwXCI+Q3JlZGl0IENhcmQgRXhwaXJhdGlvbiBNb250aCZsdDsvbGFiZWw+XG4mbHQ7TWFza2VkSW5wdXRcbiAgICBpZD1cImNjLWV4cFwiXG4gICAgcGF0dGVybj1cIigxWzAtMl18MFsxLTldKVxcL1xcZFxcZFwiXG4gICAgcGxhY2Vob2xkZXI9XCJNTS9ZWVwiXG4gICAgdGl0bGU9XCIyLWRpZ2l0IG1vbnRoIGFuZCAyLWRpZ2l0IHllYXIgZ3JlYXRlciB0aGFuIDAxLzE1XCJcbiAgICB0eXBlPVwidGVsXCJcbiAgICB2YWxpZEV4YW1wbGU9XCIxMS8xOFwiXG4vPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInppcFwiPlppcCBDb2RlPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPE1hc2tlZElucHV0IGlkPVwiemlwXCIgdHlwZT1cInRlbFwiIHBsYWNlaG9sZGVyPVwiWFhYWFhcIiBwYXR0ZXJuPVwiXFxkezV9XCIgdGl0bGU9XCI1LWRpZ2l0IHppcCBjb2RlXCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJ6aXAtbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cInppcC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJ6aXBcIj5aaXAgQ29kZSZsdDsvbGFiZWw+XG4mbHQ7TWFza2VkSW5wdXRcbiAgICBpZD1cInppcFwiXG4gICAgdHlwZT1cInRlbFwiXG4gICAgcGxhY2Vob2xkZXI9XCJYWFhYWFwiXG4gICAgcGF0dGVybj1cIlxcZHs1fVwiXG4gICAgdGl0bGU9XCI1LWRpZ2l0IHppcCBjb2RlXCJcbi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiY2EtemlwXCI+Q2FuYWRpYW4gWmlwIENvZGU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8TWFza2VkSW5wdXQgaWQ9XCJjYS16aXBcIiBwbGFjZWhvbGRlcj1cIlhYWCBYWFhcIiBwYXR0ZXJuPVwiXFx3XFxkXFx3IFxcZFxcd1xcZFwiIGNoYXJzZXQ9XCJfWF8gWF9YXCIgdGl0bGU9XCI2LWNoYXJhY3RlciBhbHBoYW51bWVyaWMgemlwIGNvZGUgaW4gdGhlIGZvcm1hdCBvZiBBMUEgMUExXCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJjYS16aXAtbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cImNhLXppcC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJjYS16aXBcIj5DYW5hZGlhbiBaaXAgQ29kZSZsdDsvbGFiZWw+XG4mbHQ7TWFza2VkSW5wdXRcbiAgICBjaGFyc2V0PVwiX1hfIFhfWFwiXG4gICAgaWQ9XCJjYS16aXBcIlxuICAgIHBhdHRlcm49XCJcXHdcXGRcXHcgXFxkXFx3XFxkXCJcbiAgICBwbGFjZWhvbGRlcj1cIlhYWCBYWFhcIlxuICAgIHRpdGxlPVwiNi1jaGFyYWN0ZXIgYWxwaGFudW1lcmljIHppcCBjb2RlIGluIHRoZSBmb3JtYXQgb2YgQTFBIDFBMVwiXG4vPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInRlbFwiPlRlbGVwaG9uZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxNYXNrZWRJbnB1dCBpZD1cInRlbFwiIHBsYWNlaG9sZGVyPVwiKFhYWCkgWFhYLVhYWFhcIiBwYXR0ZXJuPVwiXFwoXFxkezN9XFwpIFxcZHszfVxcLVxcZHs0fVwiICB0aXRsZT1cIjEwLWRpZ2l0IG51bWJlclwiIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlXCIgZm9yPVwidGVsLW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJ0ZWwtbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwidGVsXCI+VGVsZXBob25lJmx0Oy9sYWJlbD5cbiZsdDtNYXNrZWRJbnB1dFxuICAgIGlkPVwidGVsXCJcbiAgICBwYXR0ZXJuPVwiXFwoXFxkezN9XFwpIFxcZHszfVxcLVxcZHs0fVwiXG4gICAgcGxhY2Vob2xkZXI9XCIoWFhYKSBYWFgtWFhYWFwiXG4gICAgdGl0bGU9XCIxMC1kaWdpdCBudW1iZXJcIlxuLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPC9wcmU+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJjY1wiPkNyZWRpdCBDYXJkIE51bWJlcjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxNYXNrZWRJbnB1dCBpZD1cImNjXCIgcGxhY2Vob2xkZXI9XCJYWFhYIFhYWFggWFhYWCBYWFhYXCIgcGF0dGVybj1cIlxcZHs0fSBcXGR7NH0gXFxkezR9IFxcZHs0fVwiIHRpdGxlPVwiMTYtZGlnaXQgbnVtYmVyXCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJjYy1tYXJrdXBcIj5TaG93IE1hcmt1cDwvbGFiZWw+PGlucHV0IGlkPVwiY2MtbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwiY2NcIj5DcmVkaXQgQ2FyZCBOdW1iZXImbHQ7L2xhYmVsPlxuJmx0O01hc2tlZElucHV0XG4gICAgaWQ9XCJjY1wiXG4gICAgcGF0dGVybj1cIlxcZHs0fSBcXGR7NH0gXFxkezR9IFxcZHs0fVwiXG4gICAgcGxhY2Vob2xkZXI9XCJYWFhYIFhYWFggWFhYWCBYWFhYXCJcbiAgICB0aXRsZT1cIjE2LWRpZ2l0IG51bWJlclwiXG4vPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW1cIj5cbiAgICAgICAgICAgIDxoMj5Gb3JtYXR0ZWQgSW5wdXRzPC9oMj5cbiAgICAgICAgICAgIDxocj5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJudW1iZXJcIj5OdW1iZXI8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkSW5wdXQgaWQ9XCJudW1iZXJcIiBwbGFjZWhvbGRlcj1cIjAuMDBcIiBmb3JtYXQ9XCJudW1iZXJcIiAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRvZ2dsZVwiIGZvcj1cIm51bWJlci1tYXJrdXBcIj5TaG93IE1hcmt1cDwvbGFiZWw+PGlucHV0IGlkPVwibnVtYmVyLW1hcmt1cFwiIHR5cGU9XCJjaGVja2JveFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPHByZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlPlxuJmx0O2xhYmVsIGZvcj1cIm51bWJlclwiPk51bWJlciZsdDsvbGFiZWw+XG4mbHQ7Rm9ybWF0dGVkSW5wdXQgaWQ9XCJudW1iZXJcIiBwbGFjZWhvbGRlcj1cIjAuMDBcIiBmb3JtYXQ9XCJudW1iZXJcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImludFwiPkludDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxGb3JtYXR0ZWRJbnB1dCBpZD1cImludFwiIHBsYWNlaG9sZGVyPVwiWFwiIGZvcm1hdD1cImludFwiIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlXCIgZm9yPVwiaW50LW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJpbnQtbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwiaW50XCI+SW50Jmx0Oy9sYWJlbD5cbiZsdDtGb3JtYXR0ZWRJbnB1dCBpZD1cImludFwiIHBsYWNlaG9sZGVyPVwiWFwiIGZvcm1hdD1cImludFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiY3VycmVuY3lcIj5DdXJyZW5jeTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxGb3JtYXR0ZWRJbnB1dCBpZD1cImN1cnJlbmN5XCIgcGxhY2Vob2xkZXI9XCIkWC5YWFwiIGZvcm1hdD1cImN1cnJlbmN5XCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJjdXJyZW5jeS1tYXJrdXBcIj5TaG93IE1hcmt1cDwvbGFiZWw+PGlucHV0IGlkPVwiY3VycmVuY3ktbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwiY3VycmVuY3lcIj5DdXJyZW5jeSZsdDsvbGFiZWw+XG4mbHQ7Rm9ybWF0dGVkSW5wdXQgaWQ9XCJjdXJyZW5jeVwiIHBsYWNlaG9sZGVyPVwiJFguWFhcIiBmb3JtYXQ9XCJjdXJyZW5jeVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiY3VycmVuY3lJbnRcIj5DdXJyZW5jeSBJbnQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkSW5wdXQgaWQ9XCJjdXJyZW5jeUludFwiIHBsYWNlaG9sZGVyPVwiJFhcIiBmb3JtYXQ9XCJjdXJyZW5jeUludFwiIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlXCIgZm9yPVwiY3VycmVuY3ktaW50LW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJjdXJyZW5jeS1pbnQtbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwiY3VycmVuY3lJbnRcIj5DdXJyZW5jeSBJbnQmbHQ7L2xhYmVsPlxuJmx0O0Zvcm1hdHRlZElucHV0IGlkPVwiY3VycmVuY3lJbnRcIiBwbGFjZWhvbGRlcj1cIiRYXCIgZm9ybWF0PVwiY3VycmVuY3lJbnRcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImN1cnJlbmN5SW50XCI+UGVyY2VudCBJbnQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkSW5wdXQgaWQ9XCJjdXJyZW5jeUludFwiIHBsYWNlaG9sZGVyPVwiWFwiIGZvcm1hdD1cInBlcmNlbnRJbnRcIiAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRvZ2dsZVwiIGZvcj1cInBlcmNlbnQtaW50LW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJwZXJjZW50LWludC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJjdXJyZW5jeUludFwiPlBlcmNlbnQgSW50Jmx0Oy9sYWJlbD5cbiZsdDtGb3JtYXR0ZWRJbnB1dCBpZD1cImN1cnJlbmN5SW50XCIgcGxhY2Vob2xkZXI9XCJYXCIgZm9ybWF0PVwicGVyY2VudEludFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbWFpbj5cbiIsImltcG9ydCBBcHAgZnJvbSAnLi9BcHAuc3ZlbHRlJztcblxuY29uc3QgYXBwID0gbmV3IEFwcCh7XG4gICAgcHJvcHM6IHtcbiAgICAgICAgbmFtZTogJ1N2ZWx0ZSBNYXNrZWQgSW5wdXQnLFxuICAgIH0sXG4gICAgdGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFwcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///815\n')}},__webpack_exports__={};__webpack_modules__[815]()})();