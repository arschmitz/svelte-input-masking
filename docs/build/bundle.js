(()=>{"use strict";var __webpack_modules__={815:()=>{eval('\n// UNUSED EXPORTS: default\n\n;// CONCATENATED MODULE: ./node_modules/svelte/internal/index.mjs\nfunction noop() { }\nconst identity = x => x;\nfunction internal_assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === \'object\' && typeof value.then === \'function\';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === \'function\';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === \'object\') || typeof a === \'function\');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement(\'a\');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== \'function\') {\n        throw new Error(`\'${name}\' is not a store with a \'subscribe\' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? internal_assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === \'object\') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== \'$\')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== \'$\')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? \'\' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== \'undefined\';\nlet now = (/* unused pure expression or super */ null && (is_client\n    ? () => window.performance.now()\n    : () => Date.now()));\nlet raf = (/* unused pure expression or super */ null && (is_client ? cb => requestAnimationFrame(cb) : noop));\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === \'HEAD\') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = internal_element(\'style\');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = internal_element(\'style\');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction internal_element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS(\'http://www.w3.org/2000/svg\', name);\n}\nfunction internal_text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return internal_text(\' \');\n}\nfunction empty() {\n    return internal_text(\'\');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction internal_self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === \'style\') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === \'__value\') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === \'boolean\' && value === \'\' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS(\'http://www.w3.org/1999/xlink\', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === \'\' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don\'t go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can\'t find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, internal_element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = \'\' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => internal_text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, \' \');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, \'HTML_TAG_START\', 0);\n    const end_index = find_comment(nodes, \'HTML_TAG_END\', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = \'\' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? \'\' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? \'important\' : \'\');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(\':checked\') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(\':checked\'), option => option.__value);\n}\n// unfortunately this can\'t be a constant as that wouldn\'t be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== \'undefined\' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === \'static\') {\n        node.style.position = \'relative\';\n    }\n    const iframe = internal_element(\'iframe\');\n    iframe.setAttribute(\'style\', \'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \' +\n        \'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;\');\n    iframe.setAttribute(\'aria-hidden\', \'true\');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,\'*\')}<\/script>";\n        unsubscribe = listen(window, \'message\', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = \'about:blank\';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, \'resize\', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? \'add\' : \'remove\'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent(\'CustomEvent\');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = internal_element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends (/* unused pure expression or super */ null && (HtmlTag)) {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || \'default\'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = \'{\\n\';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || \'\';\n    node.style.animation = `${animation ? `${animation}, ` : \'\'}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || \'\').split(\', \');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf(\'__svelte\') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(\', \');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== \'absolute\' && style.position !== \'fixed\') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = \'absolute\';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === \'none\' ? \'\' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(\'Function called outside component initialization\');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the "parent" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? \'intro\' : \'outro\'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, \'start\'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, \'end\');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, \'start\'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, \'end\');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don\'t need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there\'s a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, \'start\'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, \'start\');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, \'end\');\n                        if (!pending_program) {\n                            // we\'re done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== \'undefined\'\n    ? window\n    : typeof globalThis !== \'undefined\'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(\'Cannot have duplicate keys in a keyed each\');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === \'object\' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    \'allowfullscreen\',\n    \'allowpaymentrequest\',\n    \'async\',\n    \'autofocus\',\n    \'autoplay\',\n    \'checked\',\n    \'controls\',\n    \'default\',\n    \'defer\',\n    \'disabled\',\n    \'formnovalidate\',\n    \'hidden\',\n    \'ismap\',\n    \'loop\',\n    \'multiple\',\n    \'muted\',\n    \'nomodule\',\n    \'novalidate\',\n    \'open\',\n    \'playsinline\',\n    \'readonly\',\n    \'required\',\n    \'reversed\',\n    \'selected\'\n]);\n\nconst invalid_attribute_name_character = /[\\s\'">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += \' \' + classes_to_add;\n        }\n    }\n    let str = \'\';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \' \' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \' \' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}="${value}"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    \'"\': \'&quot;\',\n    "\'": \'&#39;\',\n    \'&\': \'&amp;\',\n    \'<\': \'&lt;\',\n    \'>\': \'&gt;\'\n};\nfunction internal_escape(html) {\n    return String(html).replace(/["\'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === \'string\' ? internal_escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = \'\';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => \'\'\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === \'svelte:component\')\n            name += \' this={...}\';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + \' \' : \'\'}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return \'\';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: \'\', head: \'\', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join(\'\\n\'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return \'\';\n    return ` ${name}${value === true ? \'\' : `=${typeof value === \'string\' ? JSON.stringify(internal_escape(value)) : `"${value}"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class="${classes}"` : \'\';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === \'function\') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: \'open\' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: \'3.44.3\' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev(\'SvelteDOMInsert\', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\'SvelteDOMRemove\', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\'capture\'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push(\'preventDefault\');\n    if (has_stop_propagation)\n        modifiers.push(\'stopPropagation\');\n    dispatch_dev(\'SvelteDOMAddEventListener\', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\'SvelteDOMRemoveEventListener\', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\'SvelteDOMRemoveAttribute\', { node, attribute });\n    else\n        dispatch_dev(\'SvelteDOMSetAttribute\', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\'SvelteDOMSetProperty\', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\'SvelteDOMSetDataset\', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = \'\' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev(\'SvelteDOMSetData\', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== \'string\' && !(arg && typeof arg === \'object\' && \'length\' in arg)) {\n        let msg = \'{#each} only iterates over array-like objects.\';\n        if (typeof Symbol === \'function\' && arg && Symbol.iterator in arg) {\n            msg += \' You can use a spread to convert this iterable into an array.\';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends (/* unused pure expression or super */ null && (SvelteComponent)) {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error("\'target\' is a required option");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(\'Component was already destroyed\'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from "svelte";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang="ts">\n * \timport { MyComponent } from "component-library";\n * <\/script>\n * <MyComponent foo={\'bar\'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(\'Infinite loop detected\');\n        }\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./src/components/MaskedInput.svelte\n/* src/components/MaskedInput.svelte generated by Svelte v3.44.3 */\n\n\nfunction add_css(target) {\n\tappend_styles(target, "svelte-19ixuh6", ".svelte-19ixuh6.svelte-19ixuh6:invalid{outline:1px solid red}.shell.svelte-19ixuh6.svelte-19ixuh6{position:relative;line-height:1}.shell.svelte-19ixuh6 span.svelte-19ixuh6{position:absolute;top:50%;left:4px;transform:translateY(-50%);color:#ccc;pointer-events:none;z-index:-1}.shell.svelte-19ixuh6 span i.svelte-19ixuh6{font-style:normal;color:transparent;opacity:0;visibility:hidden}input.masked.svelte-19ixuh6.svelte-19ixuh6,.shell.svelte-19ixuh6 span.svelte-19ixuh6{font-size:16px;font-family:monospace;padding-right:10px;background-color:transparent;text-transform:uppercase}");\n}\n\nfunction create_fragment(ctx) {\n\tlet span1;\n\tlet span0;\n\tlet t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "";\n\tlet t0;\n\tlet i;\n\tlet t1;\n\tlet t2;\n\tlet t3;\n\tlet input;\n\tlet input_maxlength_value;\n\tlet mounted;\n\tlet dispose;\n\n\tlet input_levels = [\n\t\t{ class: "masked" },\n\t\t{ pattern: /*currentPattern*/ ctx[5] },\n\t\t{ value: /*rawValue*/ ctx[3] },\n\t\t{\n\t\t\tmaxlength: input_maxlength_value = /*placeholder*/ ctx[2].length\n\t\t},\n\t\t/*$$restProps*/ ctx[9]\n\t];\n\n\tlet input_data = {};\n\n\tfor (let i = 0; i < input_levels.length; i += 1) {\n\t\tinput_data = internal_assign(input_data, input_levels[i]);\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tspan1 = internal_element("span");\n\t\t\tspan0 = internal_element("span");\n\t\t\tt0 = internal_text(t0_value);\n\t\t\ti = internal_element("i");\n\t\t\tt1 = internal_text(/*hiddenValue*/ ctx[7]);\n\t\t\tt2 = internal_text(/*remainingMask*/ ctx[6]);\n\t\t\tt3 = space();\n\t\t\tinput = internal_element("input");\n\t\t\tattr(i, "class", "svelte-19ixuh6");\n\t\t\tattr(span0, "aria-hidden", "true");\n\t\t\tattr(span0, "class", "svelte-19ixuh6");\n\t\t\tset_attributes(input, input_data);\n\t\t\ttoggle_class(input, "svelte-19ixuh6", true);\n\t\t\tattr(span1, "class", "shell svelte-19ixuh6");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, span1, anchor);\n\t\t\tappend(span1, span0);\n\t\t\tappend(span0, t0);\n\t\t\tappend(span0, i);\n\t\t\tappend(i, t1);\n\t\t\tappend(span0, t2);\n\t\t\tappend(span1, t3);\n\t\t\tappend(span1, input);\n\t\t\tinput.value = input_data.value;\n\t\t\tif (input.autofocus) input.focus();\n\t\t\t/*input_binding*/ ctx[16](input);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = listen(input, "keyup", /*update*/ ctx[8]);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tif (dirty & /*value, prefix*/ 3 && t0_value !== (t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "")) set_data(t0, t0_value);\n\t\t\tif (dirty & /*hiddenValue*/ 128) set_data(t1, /*hiddenValue*/ ctx[7]);\n\t\t\tif (dirty & /*remainingMask*/ 64) set_data(t2, /*remainingMask*/ ctx[6]);\n\n\t\t\tset_attributes(input, input_data = get_spread_update(input_levels, [\n\t\t\t\t{ class: "masked" },\n\t\t\t\tdirty & /*currentPattern*/ 32 && { pattern: /*currentPattern*/ ctx[5] },\n\t\t\t\tdirty & /*rawValue*/ 8 && input.value !== /*rawValue*/ ctx[3] && { value: /*rawValue*/ ctx[3] },\n\t\t\t\tdirty & /*placeholder*/ 4 && input_maxlength_value !== (input_maxlength_value = /*placeholder*/ ctx[2].length) && { maxlength: input_maxlength_value },\n\t\t\t\tdirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]\n\t\t\t]));\n\n\t\t\tif (\'value\' in input_data) {\n\t\t\t\tinput.value = input_data.value;\n\t\t\t}\n\n\t\t\ttoggle_class(input, "svelte-19ixuh6", true);\n\t\t},\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(span1);\n\t\t\t/*input_binding*/ ctx[16](null);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet hiddenValue;\n\tlet usedPattern;\n\n\tconst omit_props_names = [\n\t\t"letter","number","placeholder","validExample","value","charset","pattern","prefix","required"\n\t];\n\n\tlet $$restProps = compute_rest_props($$props, omit_props_names);\n\tlet { letter = \'_\' } = $$props;\n\tlet { number = \'XdDmMyY9\' } = $$props;\n\tlet { placeholder = \'\' } = $$props;\n\tlet { validExample = \'\' } = $$props;\n\tlet { value = \'\' } = $$props;\n\tlet { charset = null } = $$props;\n\tlet { pattern = \'\' } = $$props;\n\tlet { prefix = \'\' } = $$props;\n\tlet { required = false } = $$props;\n\tlet rawValue = \'\';\n\tlet inputElement;\n\tlet currentPattern = null;\n\tlet remainingMask = placeholder;\n\n\tasync function update(event) {\n\t\tconst cursorPosBefore = inputElement.selectionStart;\n\t\tlet cursorPosAfter;\n\t\t$$invalidate(3, rawValue = inputElement.value);\n\n\t\t$$invalidate(0, value = charset\n\t\t? rawValue.replace(/\\W/g, \'\')\n\t\t: rawValue.replace(/[^\\d.-]/g, \'\'));\n\n\t\t$$invalidate(5, currentPattern = null);\n\t\tevent.preventDefault();\n\t\tcursorPosAfter = inputElement.selectionStart;\n\t\tupdateMask();\n\t\t$$invalidate(5, currentPattern = usedPattern);\n\n\t\tif (cursorPosAfter - cursorPosBefore > 1) {\n\t\t\t$$invalidate(4, inputElement.selectionStart = cursorPosBefore, inputElement);\n\t\t\t$$invalidate(4, inputElement.selectionEnd = cursorPosBefore, inputElement);\n\t\t}\n\t}\n\n\tfunction updateMask() {\n\t\tlet newValue = \'\';\n\t\tconst strippedValue = value.replace(/\\D/g, \'\');\n\n\t\tfor (let i = 0, j = 0; i < placeholder.length; i++) {\n\t\t\tconst isInt = !Number.isNaN(parseInt(strippedValue[j], 10));\n\n\t\t\tconst isLetter = strippedValue[j]\n\t\t\t? strippedValue[j].match(/[A-Z]/i)\n\t\t\t: false;\n\n\t\t\tconst matchesNumber = number.indexOf(placeholder[i]) >= 0;\n\t\t\tconst matchesLetter = letter.indexOf(placeholder[i]) >= 0;\n\n\t\t\tif (matchesNumber && isInt || charset && matchesLetter && isLetter) {\n\t\t\t\tnewValue += strippedValue[j++];\n\t\t\t} else if (!charset && !isInt && matchesNumber || charset && (matchesLetter && !isLetter || matchesNumber && !isInt)) {\n\t\t\t\tconsole.error(\'Invalid Character\');\n\t\t\t\t$$invalidate(3, rawValue = newValue);\n\t\t\t} else {\n\t\t\t\tnewValue += placeholder[i];\n\t\t\t}\n\n\t\t\t// break if no characters left and the pattern is non-special character\n\t\t\tif (strippedValue[j] === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (validExample) {\n\t\t\t$$invalidate(0, value = validateProgress(newValue));\n\t\t}\n\n\t\t$$invalidate(3, rawValue = newValue);\n\t\t$$invalidate(6, remainingMask = placeholder.substring(rawValue.length));\n\t\t$$invalidate(5, currentPattern = usedPattern);\n\t}\n\n\tfunction validateProgress(newValue) {\n\t\tlet testValue = \'\';\n\t\tconst patternRegEx = new RegExp(pattern);\n\n\t\t// Convert to months\n\t\tif (newValue.length === 1 && placeholder.toUpperCase().substring(0, 2) === \'MM\') {\n\t\t\tif (newValue > 1 && newValue < 10) {\n\t\t\t\tnewValue = `0${newValue}`;\n\t\t\t}\n\n\t\t\treturn newValue;\n\t\t}\n\n\t\t// test the value, removing the last character, until what you have is a submatch\n\t\tfor (let i = newValue.length; i >= 0; i--) {\n\t\t\ttestValue = newValue + validExample.substring(newValue.length);\n\n\t\t\tif (patternRegEx.test(testValue)) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\n\t\t\tnewValue = newValue.substring(0, newValue.length - 1);\n\t\t}\n\n\t\treturn newValue;\n\t}\n\n\tfunction input_binding($$value) {\n\t\tbinding_callbacks[$$value ? \'unshift\' : \'push\'](() => {\n\t\t\tinputElement = $$value;\n\t\t\t$$invalidate(4, inputElement);\n\t\t});\n\t}\n\n\t$$self.$$set = $$new_props => {\n\t\t$$props = internal_assign(internal_assign({}, $$props), exclude_internal_props($$new_props));\n\t\t$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));\n\t\tif (\'letter\' in $$new_props) $$invalidate(10, letter = $$new_props.letter);\n\t\tif (\'number\' in $$new_props) $$invalidate(11, number = $$new_props.number);\n\t\tif (\'placeholder\' in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);\n\t\tif (\'validExample\' in $$new_props) $$invalidate(12, validExample = $$new_props.validExample);\n\t\tif (\'value\' in $$new_props) $$invalidate(0, value = $$new_props.value);\n\t\tif (\'charset\' in $$new_props) $$invalidate(13, charset = $$new_props.charset);\n\t\tif (\'pattern\' in $$new_props) $$invalidate(14, pattern = $$new_props.pattern);\n\t\tif (\'prefix\' in $$new_props) $$invalidate(1, prefix = $$new_props.prefix);\n\t\tif (\'required\' in $$new_props) $$invalidate(15, required = $$new_props.required);\n\t};\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty & /*prefix*/ 2) {\n\t\t\t$: $$invalidate(1, prefix = prefix || \'\');\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*prefix, rawValue*/ 10) {\n\t\t\t$: $$invalidate(3, rawValue = prefix && !rawValue ? \' \' : rawValue);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*charset, rawValue*/ 8200) {\n\t\t\t$: $$invalidate(0, value = charset\n\t\t\t? rawValue.replace(/\\W/g, \'\')\n\t\t\t: rawValue.replace(/[^\\d.-]/g, \'\'));\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*prefix, rawValue*/ 10) {\n\t\t\t$: $$invalidate(7, hiddenValue = prefix && rawValue === \' \' ? \'\' : rawValue);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*prefix, placeholder*/ 6) {\n\t\t\t$: $$invalidate(6, remainingMask = prefix ? placeholder.replace(prefix, \'\') : placeholder);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*required, value, pattern*/ 49153) {\n\t\t\t$: usedPattern = required || value ? pattern : null;\n\t\t}\n\t};\n\n\treturn [\n\t\tvalue,\n\t\tprefix,\n\t\tplaceholder,\n\t\trawValue,\n\t\tinputElement,\n\t\tcurrentPattern,\n\t\tremainingMask,\n\t\thiddenValue,\n\t\tupdate,\n\t\t$$restProps,\n\t\tletter,\n\t\tnumber,\n\t\tvalidExample,\n\t\tcharset,\n\t\tpattern,\n\t\trequired,\n\t\tinput_binding\n\t];\n}\n\nclass MaskedInput extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\tinit(\n\t\t\tthis,\n\t\t\toptions,\n\t\t\tinstance,\n\t\t\tcreate_fragment,\n\t\t\tsafe_not_equal,\n\t\t\t{\n\t\t\t\tletter: 10,\n\t\t\t\tnumber: 11,\n\t\t\t\tplaceholder: 2,\n\t\t\t\tvalidExample: 12,\n\t\t\t\tvalue: 0,\n\t\t\t\tcharset: 13,\n\t\t\t\tpattern: 14,\n\t\t\t\tprefix: 1,\n\t\t\t\trequired: 15\n\t\t\t},\n\t\t\tadd_css\n\t\t);\n\t}\n}\n\n/* harmony default export */ const MaskedInput_svelte = (MaskedInput);\n;// CONCATENATED MODULE: ./src/components/FormattedInput.svelte\n/* src/components/FormattedInput.svelte generated by Svelte v3.44.3 */\n\n\nfunction FormattedInput_svelte_add_css(target) {\n\tappend_styles(target, "svelte-43cpcp", ".svelte-43cpcp.svelte-43cpcp:invalid{outline:1px solid red}.shell.svelte-43cpcp.svelte-43cpcp{position:relative;line-height:1}.shell.svelte-43cpcp>span.svelte-43cpcp{position:absolute;top:50%;left:4px;transform:translateY(-50%);color:#ccc;pointer-events:none;z-index:-1}.shell.svelte-43cpcp span i.svelte-43cpcp{font-style:normal;color:transparent;opacity:0;visibility:hidden}input.masked.svelte-43cpcp.svelte-43cpcp,.shell.svelte-43cpcp>span.svelte-43cpcp{font-size:16px;font-family:monospace;padding-right:10px;background-color:transparent;text-transform:uppercase}.suffix.svelte-43cpcp.svelte-43cpcp{color:initial}");\n}\n\nfunction FormattedInput_svelte_create_fragment(ctx) {\n\tlet span2;\n\tlet span1;\n\tlet t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "";\n\tlet t0;\n\tlet i;\n\tlet t1;\n\tlet t2;\n\tlet span0;\n\tlet t3;\n\tlet t4;\n\tlet input;\n\tlet mounted;\n\tlet dispose;\n\n\tlet input_levels = [\n\t\t{ class: "masked" },\n\t\t{ pattern: /*currentPattern*/ ctx[5] },\n\t\t/*$$restProps*/ ctx[9]\n\t];\n\n\tlet input_data = {};\n\n\tfor (let i = 0; i < input_levels.length; i += 1) {\n\t\tinput_data = internal_assign(input_data, input_levels[i]);\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tspan2 = internal_element("span");\n\t\t\tspan1 = internal_element("span");\n\t\t\tt0 = internal_text(t0_value);\n\t\t\ti = internal_element("i");\n\t\t\tt1 = internal_text(/*hiddenValue*/ ctx[7]);\n\t\t\tt2 = internal_text(/*remainingMask*/ ctx[6]);\n\t\t\tspan0 = internal_element("span");\n\t\t\tt3 = internal_text(/*suffix*/ ctx[3]);\n\t\t\tt4 = space();\n\t\t\tinput = internal_element("input");\n\t\t\tattr(i, "class", "svelte-43cpcp");\n\t\t\tattr(span0, "class", "suffix svelte-43cpcp");\n\t\t\tattr(span1, "aria-hidden", "true");\n\t\t\tattr(span1, "class", "svelte-43cpcp");\n\t\t\tset_attributes(input, input_data);\n\t\t\ttoggle_class(input, "svelte-43cpcp", true);\n\t\t\tattr(span2, "class", "shell svelte-43cpcp");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, span2, anchor);\n\t\t\tappend(span2, span1);\n\t\t\tappend(span1, t0);\n\t\t\tappend(span1, i);\n\t\t\tappend(i, t1);\n\t\t\tappend(span1, t2);\n\t\t\tappend(span1, span0);\n\t\t\tappend(span0, t3);\n\t\t\tappend(span2, t4);\n\t\t\tappend(span2, input);\n\t\t\tif (input.autofocus) input.focus();\n\t\t\t/*input_binding*/ ctx[20](input);\n\t\t\tset_input_value(input, /*rawValue*/ ctx[2]);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = [\n\t\t\t\t\tlisten(input, "input", /*input_input_handler*/ ctx[21]),\n\t\t\t\t\tlisten(input, "keyup", /*update*/ ctx[8])\n\t\t\t\t];\n\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tif (dirty[0] & /*value, prefix*/ 3 && t0_value !== (t0_value = (/*value*/ ctx[0].length ? \'\' : /*prefix*/ ctx[1]) + "")) set_data(t0, t0_value);\n\t\t\tif (dirty[0] & /*hiddenValue*/ 128) set_data(t1, /*hiddenValue*/ ctx[7]);\n\t\t\tif (dirty[0] & /*remainingMask*/ 64) set_data(t2, /*remainingMask*/ ctx[6]);\n\t\t\tif (dirty[0] & /*suffix*/ 8) set_data(t3, /*suffix*/ ctx[3]);\n\n\t\t\tset_attributes(input, input_data = get_spread_update(input_levels, [\n\t\t\t\t{ class: "masked" },\n\t\t\t\tdirty[0] & /*currentPattern*/ 32 && { pattern: /*currentPattern*/ ctx[5] },\n\t\t\t\tdirty[0] & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]\n\t\t\t]));\n\n\t\t\tif (dirty[0] & /*rawValue*/ 4 && input.value !== /*rawValue*/ ctx[2]) {\n\t\t\t\tset_input_value(input, /*rawValue*/ ctx[2]);\n\t\t\t}\n\n\t\t\ttoggle_class(input, "svelte-43cpcp", true);\n\t\t},\n\t\ti: noop,\n\t\to: noop,\n\t\td(detaching) {\n\t\t\tif (detaching) detach(span2);\n\t\t\t/*input_binding*/ ctx[20](null);\n\t\t\tmounted = false;\n\t\t\trun_all(dispose);\n\t\t}\n\t};\n}\n\nfunction getFractionDigits(number) {\n\tvar _a;\n\n\treturn (_a = String(number).split(\'.\')[1]) === null || _a === void 0\n\t? void 0\n\t: _a.length;\n}\n\nfunction truncateFractionDigits(number, digits) {\n\tlet [int, decimal] = `${number}`.split(\'.\');\n\treturn parseFloat(`${int}.${decimal.substring(0, digits)}`);\n}\n\nfunction FormattedInput_svelte_instance($$self, $$props, $$invalidate) {\n\tlet suffix;\n\tlet hiddenValue;\n\tlet placeholderDecimal;\n\tlet placeholderDecimalLength;\n\tlet usedPattern;\n\n\tconst omit_props_names = [\n\t\t"placeholder","value","pattern","format","prefix","required","formatter","locale","currency","formatOptions"\n\t];\n\n\tlet $$restProps = compute_rest_props($$props, omit_props_names);\n\tlet { placeholder = \'\' } = $$props;\n\tlet { value = \'\' } = $$props;\n\tlet { pattern = \'\' } = $$props;\n\tlet { format = \'\' } = $$props;\n\tlet { prefix = \'\' } = $$props;\n\tlet { required = false } = $$props;\n\tlet { formatter = null } = $$props;\n\tlet { locale = \'en-us\' } = $$props;\n\tlet { currency = \'USD\' } = $$props;\n\tlet { formatOptions = null } = $$props;\n\tlet rawValue = \'\';\n\tlet inputElement;\n\tlet currentPattern = null;\n\tlet remainingMask = placeholder;\n\tlet significantDigits = 1;\n\tlet decimalRegExp = null;\n\tlet decimalEndRegExp = null;\n\tlet seperators = {};\n\tconst log10 = Math.log(10);\n\n\tfunction getSeperators(_) {\n\t\tconst numberWithGroupAndDecimalSeparator = 1000.1;\n\n\t\treturn Intl.NumberFormat(locale).formatToParts(numberWithGroupAndDecimalSeparator).reduce(\n\t\t\t(collection, part) => {\n\t\t\t\tif (part.type === \'decimal\' || part.type === \'group\') {\n\t\t\t\t\tcollection[part.type] = part.value;\n\t\t\t\t}\n\n\t\t\t\treturn collection;\n\t\t\t},\n\t\t\t{}\n\t\t);\n\t}\n\n\tfunction getSignificantDigitCount(n) {\n\t\tn = Math.abs(parseFloat(String(n).replace(seperators.decimal, \'\')));\n\n\t\tif (n === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (n !== 0 && n % 10 === 0) {\n\t\t\tn /= 10;\n\t\t}\n\n\t\treturn Math.floor(Math.log(n) / log10) + 1;\n\t}\n\n\tconst formats = {\n\t\tcurrency(input) {\n\t\t\tconst options = formatOptions || {\n\t\t\t\tcurrency,\n\t\t\t\tmaximumFractionDigits: 2,\n\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\tstyle: \'currency\'\n\t\t\t};\n\n\t\t\tconst maximumFractionDigits = options.maximumFractionDigits;\n\n\t\t\tif (getFractionDigits(input) >= maximumFractionDigits) {\n\t\t\t\tinput = truncateFractionDigits(input, maximumFractionDigits);\n\t\t\t}\n\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale, options);\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tcurrencyInt(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\tformatOptions || {\n\t\t\t\t\tcurrency,\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\t\tstyle: \'currency\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tint(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\tformatOptions || {\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\t\tstyle: \'decimal\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tnumber(input) {\n\t\t\tconst options = formatOptions || {\n\t\t\t\tmaximumFractionDigits: 3,\n\t\t\t\tminimumSignificantDigits: significantDigits,\n\t\t\t\tstyle: \'decimal\'\n\t\t\t};\n\n\t\t\tconst maximumFractionDigits = options.maximumFractionDigits;\n\n\t\t\tif (getFractionDigits(input) >= maximumFractionDigits) {\n\t\t\t\tinput = truncateFractionDigits(input, maximumFractionDigits);\n\t\t\t}\n\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale, options);\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tpercent(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale,\n\t\t\tformatOptions || {\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t\tstyle: \'percent\'\n\t\t\t\t});\n\n\t\t\treturn formatFunction.format(input);\n\t\t},\n\t\tpercentInt(input) {\n\t\t\tconst formatFunction = new Intl.NumberFormat(locale, formatOptions || { style: \'percent\' });\n\t\t\treturn formatFunction.format(input);\n\t\t}\n\t};\n\n\tfunction formatDecimals(currentFormatter) {\n\t\tconst isDecimal = decimalEndRegExp.test(inputElement.value);\n\t\tconst hasDecimal = decimalRegExp.test(inputElement.value);\n\t\tconst usedValue = isDecimal ? value.slice(0, -1) : value;\n\t\tconst intValue = parseFloat(usedValue);\n\n\t\tconst digits = intValue > 0\n\t\t? getSignificantDigitCount(value) + 1\n\t\t: Math.min(4, hasDecimal ? value.length - 1 : value.length);\n\n\t\tif (Number.isNaN(intValue)) {\n\t\t\t$$invalidate(6, remainingMask = placeholder);\n\t\t\treturn \' \';\n\t\t}\n\n\t\t$$invalidate(6, remainingMask = `${isDecimal ? \'\' : seperators.decimal}${placeholderDecimal}`);\n\t\tsignificantDigits = !(/0$/).test(rawValue) ? undefined : digits;\n\n\t\tif (hasDecimal && !isDecimal) {\n\t\t\tconst decimalLength = rawValue.split(seperators.decimal)[1].length;\n\t\t\tconst remainingDecimals = placeholderDecimalLength - decimalLength;\n\n\t\t\t$$invalidate(6, remainingMask = `${remainingDecimals > 0\n\t\t\t? placeholderDecimal.slice(-1 * decimalLength)\n\t\t\t: \'\'}`);\n\t\t}\n\n\t\treturn `${currentFormatter(intValue)}${isDecimal ? seperators.decimal : \'\'}`;\n\t}\n\n\tconst formatters = {\n\t\tcurrency: {\n\t\t\tformat() {\n\t\t\t\treturn formatDecimals(formats.currency);\n\t\t\t},\n\t\t\tpattern: \'\\\\$[0-9]{1,3}(,[0-9]{3}){0,}\',\n\t\t\tprefix: \'$\'\n\t\t},\n\t\tcurrencyInt: {\n\t\t\tformat() {\n\t\t\t\tconst intValue = parseInt(value, 10);\n\n\t\t\t\tif (Number.isNaN(intValue)) {\n\t\t\t\t\treturn \' \';\n\t\t\t\t}\n\n\t\t\t\tif (placeholder.length <= rawValue.length) {\n\t\t\t\t\t$$invalidate(6, remainingMask = \' \');\n\t\t\t\t} else {\n\t\t\t\t\tconst remainingMaskLength = placeholder.length - rawValue.length;\n\t\t\t\t\t$$invalidate(6, remainingMask = placeholder.slice(-1 * remainingMaskLength));\n\t\t\t\t}\n\n\t\t\t\treturn formats.currencyInt(intValue);\n\t\t\t},\n\t\t\tpattern: \'\\\\$[0-9]{1,3}(,[0-9]{3}){0,}\',\n\t\t\tprefix: \'$\'\n\t\t},\n\t\tint: {\n\t\t\tformat() {\n\t\t\t\tconst intValue = parseInt(value, 10);\n\n\t\t\t\tif (Number.isNaN(intValue)) {\n\t\t\t\t\treturn \' \';\n\t\t\t\t}\n\n\t\t\t\tif (placeholder.length <= rawValue.length) {\n\t\t\t\t\t$$invalidate(6, remainingMask = \'\');\n\t\t\t\t} else {\n\t\t\t\t\tconst remainingMaskLength = placeholder.length - rawValue.length;\n\t\t\t\t\t$$invalidate(6, remainingMask = placeholder.slice(-1 * remainingMaskLength));\n\t\t\t\t}\n\n\t\t\t\treturn formats.int(intValue);\n\t\t\t},\n\t\t\tpattern: \'[0-9]{1,3}(,[0-9]{3})*\\\\.[0-9]\'\n\t\t},\n\t\tnumber: {\n\t\t\tformat() {\n\t\t\t\treturn formatDecimals(formats.number);\n\t\t\t},\n\t\t\tpattern: \'[0-9]{1,3}(,[0-9]{3})*(\\\\.[0-9]+)?$\'\n\t\t},\n\t\tpercentInt: {\n\t\t\tformat() {\n\t\t\t\tconst intValue = parseInt(value, 10);\n\n\t\t\t\tif (Number.isNaN(intValue)) {\n\t\t\t\t\treturn \' \';\n\t\t\t\t}\n\n\t\t\t\tif (placeholder.length <= rawValue.length) {\n\t\t\t\t\t$$invalidate(6, remainingMask = \'\');\n\t\t\t\t} else {\n\t\t\t\t\tconst remainingMaskLength = placeholder.length - rawValue.length;\n\t\t\t\t\t$$invalidate(6, remainingMask = placeholder.slice(-1 * remainingMaskLength));\n\t\t\t\t}\n\n\t\t\t\treturn `${formats.int(intValue)}`;\n\t\t\t},\n\t\t\tsuffix: \'%\',\n\t\t\tpattern: \'[0-9]{1,})%\'\n\t\t}\n\t};\n\n\tvalue = rawValue.replace(/[^\\d.-]/g, \'\');\n\trawValue = prefix && !rawValue ? \' \' : rawValue;\n\tremainingMask = prefix ? placeholder.replace(prefix, \'\') : placeholder;\n\n\tasync function update() {\n\t\tconst cursorPosBefore = inputElement.selectionStart;\n\t\tlet cursorPosAfter;\n\t\t$$invalidate(0, value = inputElement.value.replace(/[^\\d.-]/g, \'\'));\n\t\t$$invalidate(5, currentPattern = null);\n\t\tcursorPosAfter = inputElement.selectionStart;\n\t\t$$invalidate(2, rawValue = formatters[format].format());\n\t\t$$invalidate(5, currentPattern = usedPattern);\n\n\t\tif (cursorPosAfter - cursorPosBefore > 1) {\n\t\t\t$$invalidate(4, inputElement.selectionStart = cursorPosBefore, inputElement);\n\t\t\t$$invalidate(4, inputElement.selectionEnd = cursorPosBefore, inputElement);\n\t\t}\n\t}\n\n\tfunction input_binding($$value) {\n\t\tbinding_callbacks[$$value ? \'unshift\' : \'push\'](() => {\n\t\t\tinputElement = $$value;\n\t\t\t$$invalidate(4, inputElement);\n\t\t});\n\t}\n\n\tfunction input_input_handler() {\n\t\trawValue = this.value;\n\t\t$$invalidate(2, rawValue);\n\t}\n\n\t$$self.$$set = $$new_props => {\n\t\t$$props = internal_assign(internal_assign({}, $$props), exclude_internal_props($$new_props));\n\t\t$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));\n\t\tif (\'placeholder\' in $$new_props) $$invalidate(11, placeholder = $$new_props.placeholder);\n\t\tif (\'value\' in $$new_props) $$invalidate(0, value = $$new_props.value);\n\t\tif (\'pattern\' in $$new_props) $$invalidate(12, pattern = $$new_props.pattern);\n\t\tif (\'format\' in $$new_props) $$invalidate(13, format = $$new_props.format);\n\t\tif (\'prefix\' in $$new_props) $$invalidate(1, prefix = $$new_props.prefix);\n\t\tif (\'required\' in $$new_props) $$invalidate(14, required = $$new_props.required);\n\t\tif (\'formatter\' in $$new_props) $$invalidate(10, formatter = $$new_props.formatter);\n\t\tif (\'locale\' in $$new_props) $$invalidate(15, locale = $$new_props.locale);\n\t\tif (\'currency\' in $$new_props) $$invalidate(16, currency = $$new_props.currency);\n\t\tif (\'formatOptions\' in $$new_props) $$invalidate(17, formatOptions = $$new_props.formatOptions);\n\t};\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty[0] & /*locale*/ 32768) {\n\t\t\t$: $$invalidate(18, seperators = getSeperators(locale));\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*formatter, format*/ 9216) {\n\t\t\t$: formatter || $$invalidate(10, formatter = formatters[format]);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*format, prefix*/ 8194) {\n\t\t\t$: $$invalidate(1, prefix = format ? formatters[format].prefix || \'\' : prefix || \'\');\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*format, suffix*/ 8200) {\n\t\t\t$: $$invalidate(3, suffix = format ? formatters[format].suffix || \'\' : suffix || \'\');\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*prefix, rawValue*/ 6) {\n\t\t\t$: $$invalidate(7, hiddenValue = prefix && rawValue === \' \' ? \'\' : rawValue);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*seperators*/ 262144) {\n\t\t\t$: decimalEndRegExp = new RegExp(`\\\\${seperators.decimal}$`);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*seperators*/ 262144) {\n\t\t\t$: decimalRegExp = new RegExp(`\\\\${seperators.decimal}`);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*placeholder, seperators*/ 264192) {\n\t\t\t$: $$invalidate(19, placeholderDecimal = placeholder === null || placeholder === void 0\n\t\t\t? void 0\n\t\t\t: placeholder.split(seperators.decimal)[1]);\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*placeholderDecimal*/ 524288) {\n\t\t\t$: placeholderDecimalLength = placeholderDecimal === null || placeholderDecimal === void 0\n\t\t\t? void 0\n\t\t\t: placeholderDecimal.length;\n\t\t}\n\n\t\tif ($$self.$$.dirty[0] & /*required, value, format, pattern*/ 28673) {\n\t\t\t$: usedPattern = required || value\n\t\t\t? format ? pattern || formatters[format].pattern : pattern\n\t\t\t: null;\n\t\t}\n\t};\n\n\treturn [\n\t\tvalue,\n\t\tprefix,\n\t\trawValue,\n\t\tsuffix,\n\t\tinputElement,\n\t\tcurrentPattern,\n\t\tremainingMask,\n\t\thiddenValue,\n\t\tupdate,\n\t\t$$restProps,\n\t\tformatter,\n\t\tplaceholder,\n\t\tpattern,\n\t\tformat,\n\t\trequired,\n\t\tlocale,\n\t\tcurrency,\n\t\tformatOptions,\n\t\tseperators,\n\t\tplaceholderDecimal,\n\t\tinput_binding,\n\t\tinput_input_handler\n\t];\n}\n\nclass FormattedInput extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\tinit(\n\t\t\tthis,\n\t\t\toptions,\n\t\t\tFormattedInput_svelte_instance,\n\t\t\tFormattedInput_svelte_create_fragment,\n\t\t\tsafe_not_equal,\n\t\t\t{\n\t\t\t\tplaceholder: 11,\n\t\t\t\tvalue: 0,\n\t\t\t\tpattern: 12,\n\t\t\t\tformat: 13,\n\t\t\t\tprefix: 1,\n\t\t\t\trequired: 14,\n\t\t\t\tformatter: 10,\n\t\t\t\tlocale: 15,\n\t\t\t\tcurrency: 16,\n\t\t\t\tformatOptions: 17\n\t\t\t},\n\t\t\tFormattedInput_svelte_add_css,\n\t\t\t[-1, -1]\n\t\t);\n\t}\n}\n\n/* harmony default export */ const FormattedInput_svelte = (FormattedInput);\n;// CONCATENATED MODULE: ./src/App.svelte\n/* src/App.svelte generated by Svelte v3.44.3 */\n\n\n\n\n\nfunction App_svelte_add_css(target) {\n\tappend_styles(target, "svelte-1nmrny4", ".svelte-1nmrny4.svelte-1nmrny4{box-sizing:border-box}main.svelte-1nmrny4.svelte-1nmrny4{text-align:center;padding:1em;margin:0 auto}h1.svelte-1nmrny4.svelte-1nmrny4{color:#ff3e00;font-size:4em;font-weight:900}h2.svelte-1nmrny4.svelte-1nmrny4{font-size:2.5em}h1.svelte-1nmrny4.svelte-1nmrny4,h2.svelte-1nmrny4.svelte-1nmrny4{font-family:\\"Cutive Mono\\", monospace}body *{font-family:\\"Cutive Mono\\", monospace !important}body p{font-size:1.5rem;font-family:\\"Noto Sans JP\\", sans-serif !important}@media(min-width: 640px){main.svelte-1nmrny4.svelte-1nmrny4{max-width:none}}.grid.svelte-1nmrny4.svelte-1nmrny4{display:grid;grid-template-columns:1fr}@media(min-width: 640px){.grid.svelte-1nmrny4.svelte-1nmrny4{grid-template-columns:1fr 1fr}}li.svelte-1nmrny4>label.svelte-1nmrny4:first-child{font-size:1.25rem;display:block;font-family:\\"Noto Serif JP\\", serif !important;margin-bottom:0.5rem}.item.svelte-1nmrny4.svelte-1nmrny4{margin:2rem}img.svelte-1nmrny4.svelte-1nmrny4{width:400px}ul.svelte-1nmrny4.svelte-1nmrny4{list-style:none;padding:0}input,.shell span{padding:0.25rem;border-radius:0.25rem}li.svelte-1nmrny4.svelte-1nmrny4{text-align:left;margin-bottom:1rem}pre.svelte-1nmrny4.svelte-1nmrny4{display:none;background:black;color:white;padding:1rem;border:4px inset red}input.svelte-1nmrny4:checked+pre.svelte-1nmrny4{display:block}.toggle.svelte-1nmrny4.svelte-1nmrny4{border:1px solid;padding:0.25rem;border-radius:0.25rem;font-weight:900;cursor:pointer}.toggle.svelte-1nmrny4.svelte-1nmrny4:hover{background:#eee}.toggle.svelte-1nmrny4.svelte-1nmrny4:active{background:#333;color:white}input[type=checkbox].svelte-1nmrny4.svelte-1nmrny4{display:none}");\n}\n\nfunction App_svelte_create_fragment(ctx) {\n\tlet main;\n\tlet img;\n\tlet img_src_value;\n\tlet t0;\n\tlet h1;\n\tlet t2;\n\tlet p;\n\tlet t4;\n\tlet div2;\n\tlet div0;\n\tlet h20;\n\tlet t6;\n\tlet hr0;\n\tlet t7;\n\tlet ul0;\n\tlet li0;\n\tlet label0;\n\tlet t9;\n\tlet maskedinput0;\n\tlet t10;\n\tlet label1;\n\tlet input0;\n\tlet t12;\n\tlet pre0;\n\tlet t14;\n\tlet li1;\n\tlet label2;\n\tlet t16;\n\tlet maskedinput1;\n\tlet t17;\n\tlet label3;\n\tlet input1;\n\tlet t19;\n\tlet pre1;\n\tlet code1;\n\tlet t23;\n\tlet li2;\n\tlet label4;\n\tlet t25;\n\tlet maskedinput2;\n\tlet t26;\n\tlet label5;\n\tlet input2;\n\tlet t28;\n\tlet pre2;\n\tlet t30;\n\tlet li3;\n\tlet label6;\n\tlet t32;\n\tlet maskedinput3;\n\tlet t33;\n\tlet label7;\n\tlet input3;\n\tlet t35;\n\tlet pre3;\n\tlet code3;\n\tlet t43;\n\tlet li4;\n\tlet label8;\n\tlet t45;\n\tlet maskedinput4;\n\tlet t46;\n\tlet label9;\n\tlet input4;\n\tlet t48;\n\tlet pre4;\n\tlet code4;\n\tlet t58;\n\tlet div1;\n\tlet h21;\n\tlet t60;\n\tlet hr1;\n\tlet t61;\n\tlet ul1;\n\tlet li5;\n\tlet label10;\n\tlet t63;\n\tlet formattedinput0;\n\tlet t64;\n\tlet label11;\n\tlet input5;\n\tlet t66;\n\tlet pre5;\n\tlet t68;\n\tlet li6;\n\tlet label12;\n\tlet t70;\n\tlet formattedinput1;\n\tlet t71;\n\tlet label13;\n\tlet input6;\n\tlet t73;\n\tlet pre6;\n\tlet t75;\n\tlet li7;\n\tlet label14;\n\tlet t77;\n\tlet formattedinput2;\n\tlet t78;\n\tlet label15;\n\tlet input7;\n\tlet t80;\n\tlet pre7;\n\tlet t82;\n\tlet li8;\n\tlet label16;\n\tlet t84;\n\tlet formattedinput3;\n\tlet t85;\n\tlet label17;\n\tlet input8;\n\tlet t87;\n\tlet pre8;\n\tlet t89;\n\tlet li9;\n\tlet label18;\n\tlet t91;\n\tlet formattedinput4;\n\tlet t92;\n\tlet label19;\n\tlet input9;\n\tlet t94;\n\tlet pre9;\n\tlet current;\n\n\tmaskedinput0 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "cc-exp",\n\t\t\t\ttype: "tel",\n\t\t\t\tplaceholder: "MM/YY",\n\t\t\t\tpattern: "(1[0-2]|0[1-9])\\\\/\\\\d\\\\d",\n\t\t\t\tvalidExample: "11/18",\n\t\t\t\ttitle: "2-digit month and 2-digit year greater than 01/15"\n\t\t\t}\n\t\t});\n\n\tmaskedinput1 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "zip",\n\t\t\t\ttype: "tel",\n\t\t\t\tplaceholder: "XXXXX",\n\t\t\t\tpattern: "\\\\d" + 5,\n\t\t\t\ttitle: "5-digit zip code"\n\t\t\t}\n\t\t});\n\n\tmaskedinput2 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "ca-zip",\n\t\t\t\tplaceholder: "XXX XXX",\n\t\t\t\tpattern: "\\\\w\\\\d\\\\w \\\\d\\\\w\\\\d",\n\t\t\t\tcharset: "_X_ X_X",\n\t\t\t\ttitle: "6-character alphanumeric zip code in the format of A1A 1A1"\n\t\t\t}\n\t\t});\n\n\tmaskedinput3 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "tel",\n\t\t\t\tplaceholder: "(XXX) XXX-XXXX",\n\t\t\t\tpattern: "\\\\(\\\\d" + 3 + "\\\\) \\\\d" + 3 + "\\\\-\\\\d" + 4,\n\t\t\t\ttitle: "10-digit number"\n\t\t\t}\n\t\t});\n\n\tmaskedinput4 = new MaskedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "cc",\n\t\t\t\tplaceholder: "XXXX XXXX XXXX XXXX",\n\t\t\t\tpattern: "\\\\d" + 4 + " \\\\d" + 4 + " \\\\d" + 4 + " \\\\d" + 4,\n\t\t\t\ttitle: "16-digit number"\n\t\t\t}\n\t\t});\n\n\tformattedinput0 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "number",\n\t\t\t\tplaceholder: "0.00",\n\t\t\t\tformat: "number"\n\t\t\t}\n\t\t});\n\n\tformattedinput1 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "int",\n\t\t\t\tplaceholder: "X",\n\t\t\t\tformat: "int"\n\t\t\t}\n\t\t});\n\n\tformattedinput2 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "currency",\n\t\t\t\tplaceholder: "X.XX",\n\t\t\t\tformat: "currency"\n\t\t\t}\n\t\t});\n\n\tformattedinput3 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "currencyInt",\n\t\t\t\tplaceholder: "X",\n\t\t\t\tformat: "currencyInt"\n\t\t\t}\n\t\t});\n\n\tformattedinput4 = new FormattedInput_svelte({\n\t\t\tprops: {\n\t\t\t\tid: "currencyInt",\n\t\t\t\tplaceholder: "X",\n\t\t\t\tformat: "percentInt"\n\t\t\t}\n\t\t});\n\n\treturn {\n\t\tc() {\n\t\t\tmain = internal_element("main");\n\t\t\timg = internal_element("img");\n\t\t\tt0 = space();\n\t\t\th1 = internal_element("h1");\n\t\t\th1.textContent = "Svelte Masked Input";\n\t\t\tt2 = space();\n\t\t\tp = internal_element("p");\n\t\t\tp.textContent = "Cybernetically Enhanced Inputs with Masks for Svelte Apps";\n\t\t\tt4 = space();\n\t\t\tdiv2 = internal_element("div");\n\t\t\tdiv0 = internal_element("div");\n\t\t\th20 = internal_element("h2");\n\t\t\th20.textContent = "Masked Inputs";\n\t\t\tt6 = space();\n\t\t\thr0 = internal_element("hr");\n\t\t\tt7 = space();\n\t\t\tul0 = internal_element("ul");\n\t\t\tli0 = internal_element("li");\n\t\t\tlabel0 = internal_element("label");\n\t\t\tlabel0.textContent = "Credit Card Expiration Month";\n\t\t\tt9 = space();\n\t\t\tcreate_component(maskedinput0.$$.fragment);\n\t\t\tt10 = space();\n\t\t\tlabel1 = internal_element("label");\n\t\t\tlabel1.textContent = "Show Markup";\n\t\t\tinput0 = internal_element("input");\n\t\t\tt12 = space();\n\t\t\tpre0 = internal_element("pre");\n\n\t\t\tpre0.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;cc-exp&quot;&gt;Credit Card Expiration Month&lt;/label&gt;\n&lt;MaskedInput\n    id=&quot;cc-exp&quot;\n    pattern=&quot;(1[0-2]|0[1-9])\\\\/\\\\d\\\\d&quot;\n    placeholder=&quot;MM/YY&quot;\n    title=&quot;2-digit month and 2-digit year greater than 01/15&quot;\n    type=&quot;tel&quot;\n    validExample=&quot;11/18&quot;\n/&gt;</code>`;\n\n\t\t\tt14 = space();\n\t\t\tli1 = internal_element("li");\n\t\t\tlabel2 = internal_element("label");\n\t\t\tlabel2.textContent = "Zip Code";\n\t\t\tt16 = space();\n\t\t\tcreate_component(maskedinput1.$$.fragment);\n\t\t\tt17 = space();\n\t\t\tlabel3 = internal_element("label");\n\t\t\tlabel3.textContent = "Show Markup";\n\t\t\tinput1 = internal_element("input");\n\t\t\tt19 = space();\n\t\t\tpre1 = internal_element("pre");\n\t\t\tcode1 = internal_element("code");\n\n\t\t\tcode1.textContent = `<label for="zip">Zip Code</label>\n<MaskedInput\n    id="zip"\n    type="tel"\n    placeholder="XXXXX"\n    pattern="\\\\d${5}"\n    title="5-digit zip code"\n/>`;\n\n\t\t\tt23 = space();\n\t\t\tli2 = internal_element("li");\n\t\t\tlabel4 = internal_element("label");\n\t\t\tlabel4.textContent = "Canadian Zip Code";\n\t\t\tt25 = space();\n\t\t\tcreate_component(maskedinput2.$$.fragment);\n\t\t\tt26 = space();\n\t\t\tlabel5 = internal_element("label");\n\t\t\tlabel5.textContent = "Show Markup";\n\t\t\tinput2 = internal_element("input");\n\t\t\tt28 = space();\n\t\t\tpre2 = internal_element("pre");\n\n\t\t\tpre2.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;ca-zip&quot;&gt;Canadian Zip Code&lt;/label&gt;\n&lt;MaskedInput\n    charset=&quot;_X_ X_X&quot;\n    id=&quot;ca-zip&quot;\n    pattern=&quot;\\\\w\\\\d\\\\w \\\\d\\\\w\\\\d&quot;\n    placeholder=&quot;XXX XXX&quot;\n    title=&quot;6-character alphanumeric zip code in the format of A1A 1A1&quot;\n/&gt;</code>`;\n\n\t\t\tt30 = space();\n\t\t\tli3 = internal_element("li");\n\t\t\tlabel6 = internal_element("label");\n\t\t\tlabel6.textContent = "Telephone";\n\t\t\tt32 = space();\n\t\t\tcreate_component(maskedinput3.$$.fragment);\n\t\t\tt33 = space();\n\t\t\tlabel7 = internal_element("label");\n\t\t\tlabel7.textContent = "Show Markup";\n\t\t\tinput3 = internal_element("input");\n\t\t\tt35 = space();\n\t\t\tpre3 = internal_element("pre");\n\t\t\tcode3 = internal_element("code");\n\n\t\t\tcode3.textContent = `<label for="tel">Telephone</label>\n<MaskedInput\n    id="tel"\n    pattern="\\\\(\\\\d${3}\\\\) \\\\d${3}\\\\-\\\\d${4}"\n    placeholder="(XXX) XXX-XXXX"\n    title="10-digit number"\n/>`;\n\n\t\t\tt43 = space();\n\t\t\tli4 = internal_element("li");\n\t\t\tlabel8 = internal_element("label");\n\t\t\tlabel8.textContent = "Credit Card Number";\n\t\t\tt45 = space();\n\t\t\tcreate_component(maskedinput4.$$.fragment);\n\t\t\tt46 = space();\n\t\t\tlabel9 = internal_element("label");\n\t\t\tlabel9.textContent = "Show Markup";\n\t\t\tinput4 = internal_element("input");\n\t\t\tt48 = space();\n\t\t\tpre4 = internal_element("pre");\n\t\t\tcode4 = internal_element("code");\n\n\t\t\tcode4.textContent = `<label for="cc">Credit Card Number</label>\n<MaskedInput\n    id="cc"\n    pattern="\\\\d${4} \\\\d${4} \\\\d${4} \\\\d${4}"\n    placeholder="XXXX XXXX XXXX XXXX"\n    title="16-digit number"\n/>`;\n\n\t\t\tt58 = space();\n\t\t\tdiv1 = internal_element("div");\n\t\t\th21 = internal_element("h2");\n\t\t\th21.textContent = "Formatted Inputs";\n\t\t\tt60 = space();\n\t\t\thr1 = internal_element("hr");\n\t\t\tt61 = space();\n\t\t\tul1 = internal_element("ul");\n\t\t\tli5 = internal_element("li");\n\t\t\tlabel10 = internal_element("label");\n\t\t\tlabel10.textContent = "Number";\n\t\t\tt63 = space();\n\t\t\tcreate_component(formattedinput0.$$.fragment);\n\t\t\tt64 = space();\n\t\t\tlabel11 = internal_element("label");\n\t\t\tlabel11.textContent = "Show Markup";\n\t\t\tinput5 = internal_element("input");\n\t\t\tt66 = space();\n\t\t\tpre5 = internal_element("pre");\n\n\t\t\tpre5.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;number&quot;&gt;Number&lt;/label&gt;\n&lt;FormattedInput id=&quot;number&quot; placeholder=&quot;0.00&quot; format=&quot;number&quot; /&gt;</code>`;\n\n\t\t\tt68 = space();\n\t\t\tli6 = internal_element("li");\n\t\t\tlabel12 = internal_element("label");\n\t\t\tlabel12.textContent = "Int";\n\t\t\tt70 = space();\n\t\t\tcreate_component(formattedinput1.$$.fragment);\n\t\t\tt71 = space();\n\t\t\tlabel13 = internal_element("label");\n\t\t\tlabel13.textContent = "Show Markup";\n\t\t\tinput6 = internal_element("input");\n\t\t\tt73 = space();\n\t\t\tpre6 = internal_element("pre");\n\n\t\t\tpre6.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;int&quot;&gt;Int&lt;/label&gt;\n&lt;FormattedInput id=&quot;int&quot; placeholder=&quot;X&quot; format=&quot;int&quot; /&gt;</code>`;\n\n\t\t\tt75 = space();\n\t\t\tli7 = internal_element("li");\n\t\t\tlabel14 = internal_element("label");\n\t\t\tlabel14.textContent = "Currency";\n\t\t\tt77 = space();\n\t\t\tcreate_component(formattedinput2.$$.fragment);\n\t\t\tt78 = space();\n\t\t\tlabel15 = internal_element("label");\n\t\t\tlabel15.textContent = "Show Markup";\n\t\t\tinput7 = internal_element("input");\n\t\t\tt80 = space();\n\t\t\tpre7 = internal_element("pre");\n\n\t\t\tpre7.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;currency&quot;&gt;Currency&lt;/label&gt;\n&lt;FormattedInput id=&quot;currency&quot; placeholder=&quot;X.XX&quot; format=&quot;currency&quot; /&gt;</code>`;\n\n\t\t\tt82 = space();\n\t\t\tli8 = internal_element("li");\n\t\t\tlabel16 = internal_element("label");\n\t\t\tlabel16.textContent = "Currency Int";\n\t\t\tt84 = space();\n\t\t\tcreate_component(formattedinput3.$$.fragment);\n\t\t\tt85 = space();\n\t\t\tlabel17 = internal_element("label");\n\t\t\tlabel17.textContent = "Show Markup";\n\t\t\tinput8 = internal_element("input");\n\t\t\tt87 = space();\n\t\t\tpre8 = internal_element("pre");\n\n\t\t\tpre8.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;currencyInt&quot;&gt;Currency Int&lt;/label&gt;\n&lt;FormattedInput id=&quot;currencyInt&quot; placeholder=&quot;X&quot; format=&quot;currencyInt&quot; /&gt;</code>`;\n\n\t\t\tt89 = space();\n\t\t\tli9 = internal_element("li");\n\t\t\tlabel18 = internal_element("label");\n\t\t\tlabel18.textContent = "Percent Int";\n\t\t\tt91 = space();\n\t\t\tcreate_component(formattedinput4.$$.fragment);\n\t\t\tt92 = space();\n\t\t\tlabel19 = internal_element("label");\n\t\t\tlabel19.textContent = "Show Markup";\n\t\t\tinput9 = internal_element("input");\n\t\t\tt94 = space();\n\t\t\tpre9 = internal_element("pre");\n\n\t\t\tpre9.innerHTML = `<code class="svelte-1nmrny4">&lt;label for=&quot;currencyInt&quot;&gt;Percent Int&lt;/label&gt;\n&lt;FormattedInput id=&quot;currencyInt&quot; placeholder=&quot;X&quot; format=&quot;percentInt&quot; /&gt;</code>`;\n\n\t\t\tif (!src_url_equal(img.src, img_src_value = "./masked-input-logo.svg")) attr(img, "src", img_src_value);\n\t\t\tattr(img, "alt", "logo");\n\t\t\tattr(img, "class", "svelte-1nmrny4");\n\t\t\tattr(h1, "class", "svelte-1nmrny4");\n\t\t\tattr(p, "class", "svelte-1nmrny4");\n\t\t\tattr(h20, "class", "svelte-1nmrny4");\n\t\t\tattr(hr0, "class", "svelte-1nmrny4");\n\t\t\tattr(label0, "for", "cc-exp");\n\t\t\tattr(label0, "class", "svelte-1nmrny4");\n\t\t\tattr(label1, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label1, "for", "cc-exp-markup");\n\t\t\tattr(input0, "id", "cc-exp-markup");\n\t\t\tattr(input0, "type", "checkbox");\n\t\t\tattr(input0, "class", "svelte-1nmrny4");\n\t\t\tattr(pre0, "class", "svelte-1nmrny4");\n\t\t\tattr(li0, "class", "svelte-1nmrny4");\n\t\t\tattr(label2, "for", "zip");\n\t\t\tattr(label2, "class", "svelte-1nmrny4");\n\t\t\tattr(label3, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label3, "for", "zip-markup");\n\t\t\tattr(input1, "id", "zip-markup");\n\t\t\tattr(input1, "type", "checkbox");\n\t\t\tattr(input1, "class", "svelte-1nmrny4");\n\t\t\tattr(code1, "class", "svelte-1nmrny4");\n\t\t\tattr(pre1, "class", "svelte-1nmrny4");\n\t\t\tattr(li1, "class", "svelte-1nmrny4");\n\t\t\tattr(label4, "for", "ca-zip");\n\t\t\tattr(label4, "class", "svelte-1nmrny4");\n\t\t\tattr(label5, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label5, "for", "ca-zip-markup");\n\t\t\tattr(input2, "id", "ca-zip-markup");\n\t\t\tattr(input2, "type", "checkbox");\n\t\t\tattr(input2, "class", "svelte-1nmrny4");\n\t\t\tattr(pre2, "class", "svelte-1nmrny4");\n\t\t\tattr(li2, "class", "svelte-1nmrny4");\n\t\t\tattr(label6, "for", "tel");\n\t\t\tattr(label6, "class", "svelte-1nmrny4");\n\t\t\tattr(label7, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label7, "for", "tel-markup");\n\t\t\tattr(input3, "id", "tel-markup");\n\t\t\tattr(input3, "type", "checkbox");\n\t\t\tattr(input3, "class", "svelte-1nmrny4");\n\t\t\tattr(code3, "class", "svelte-1nmrny4");\n\t\t\tattr(pre3, "class", "svelte-1nmrny4");\n\t\t\tattr(li3, "class", "svelte-1nmrny4");\n\t\t\tattr(label8, "for", "cc");\n\t\t\tattr(label8, "class", "svelte-1nmrny4");\n\t\t\tattr(label9, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label9, "for", "cc-markup");\n\t\t\tattr(input4, "id", "cc-markup");\n\t\t\tattr(input4, "type", "checkbox");\n\t\t\tattr(input4, "class", "svelte-1nmrny4");\n\t\t\tattr(code4, "class", "svelte-1nmrny4");\n\t\t\tattr(pre4, "class", "svelte-1nmrny4");\n\t\t\tattr(li4, "class", "svelte-1nmrny4");\n\t\t\tattr(ul0, "class", "svelte-1nmrny4");\n\t\t\tattr(div0, "class", "item svelte-1nmrny4");\n\t\t\tattr(h21, "class", "svelte-1nmrny4");\n\t\t\tattr(hr1, "class", "svelte-1nmrny4");\n\t\t\tattr(label10, "for", "number");\n\t\t\tattr(label10, "class", "svelte-1nmrny4");\n\t\t\tattr(label11, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label11, "for", "number-markup");\n\t\t\tattr(input5, "id", "number-markup");\n\t\t\tattr(input5, "type", "checkbox");\n\t\t\tattr(input5, "class", "svelte-1nmrny4");\n\t\t\tattr(pre5, "class", "svelte-1nmrny4");\n\t\t\tattr(li5, "class", "svelte-1nmrny4");\n\t\t\tattr(label12, "for", "int");\n\t\t\tattr(label12, "class", "svelte-1nmrny4");\n\t\t\tattr(label13, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label13, "for", "int-markup");\n\t\t\tattr(input6, "id", "int-markup");\n\t\t\tattr(input6, "type", "checkbox");\n\t\t\tattr(input6, "class", "svelte-1nmrny4");\n\t\t\tattr(pre6, "class", "svelte-1nmrny4");\n\t\t\tattr(li6, "class", "svelte-1nmrny4");\n\t\t\tattr(label14, "for", "currency");\n\t\t\tattr(label14, "class", "svelte-1nmrny4");\n\t\t\tattr(label15, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label15, "for", "currency-markup");\n\t\t\tattr(input7, "id", "currency-markup");\n\t\t\tattr(input7, "type", "checkbox");\n\t\t\tattr(input7, "class", "svelte-1nmrny4");\n\t\t\tattr(pre7, "class", "svelte-1nmrny4");\n\t\t\tattr(li7, "class", "svelte-1nmrny4");\n\t\t\tattr(label16, "for", "currencyInt");\n\t\t\tattr(label16, "class", "svelte-1nmrny4");\n\t\t\tattr(label17, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label17, "for", "currency-int-markup");\n\t\t\tattr(input8, "id", "currency-int-markup");\n\t\t\tattr(input8, "type", "checkbox");\n\t\t\tattr(input8, "class", "svelte-1nmrny4");\n\t\t\tattr(pre8, "class", "svelte-1nmrny4");\n\t\t\tattr(li8, "class", "svelte-1nmrny4");\n\t\t\tattr(label18, "for", "currencyInt");\n\t\t\tattr(label18, "class", "svelte-1nmrny4");\n\t\t\tattr(label19, "class", "toggle svelte-1nmrny4");\n\t\t\tattr(label19, "for", "percent-int-markup");\n\t\t\tattr(input9, "id", "percent-int-markup");\n\t\t\tattr(input9, "type", "checkbox");\n\t\t\tattr(input9, "class", "svelte-1nmrny4");\n\t\t\tattr(pre9, "class", "svelte-1nmrny4");\n\t\t\tattr(li9, "class", "svelte-1nmrny4");\n\t\t\tattr(ul1, "class", "svelte-1nmrny4");\n\t\t\tattr(div1, "class", "item svelte-1nmrny4");\n\t\t\tattr(div2, "class", "grid svelte-1nmrny4");\n\t\t\tattr(main, "class", "svelte-1nmrny4");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\tinsert(target, main, anchor);\n\t\t\tappend(main, img);\n\t\t\tappend(main, t0);\n\t\t\tappend(main, h1);\n\t\t\tappend(main, t2);\n\t\t\tappend(main, p);\n\t\t\tappend(main, t4);\n\t\t\tappend(main, div2);\n\t\t\tappend(div2, div0);\n\t\t\tappend(div0, h20);\n\t\t\tappend(div0, t6);\n\t\t\tappend(div0, hr0);\n\t\t\tappend(div0, t7);\n\t\t\tappend(div0, ul0);\n\t\t\tappend(ul0, li0);\n\t\t\tappend(li0, label0);\n\t\t\tappend(li0, t9);\n\t\t\tmount_component(maskedinput0, li0, null);\n\t\t\tappend(li0, t10);\n\t\t\tappend(li0, label1);\n\t\t\tappend(li0, input0);\n\t\t\tappend(li0, t12);\n\t\t\tappend(li0, pre0);\n\t\t\tappend(ul0, t14);\n\t\t\tappend(ul0, li1);\n\t\t\tappend(li1, label2);\n\t\t\tappend(li1, t16);\n\t\t\tmount_component(maskedinput1, li1, null);\n\t\t\tappend(li1, t17);\n\t\t\tappend(li1, label3);\n\t\t\tappend(li1, input1);\n\t\t\tappend(li1, t19);\n\t\t\tappend(li1, pre1);\n\t\t\tappend(pre1, code1);\n\t\t\tappend(ul0, t23);\n\t\t\tappend(ul0, li2);\n\t\t\tappend(li2, label4);\n\t\t\tappend(li2, t25);\n\t\t\tmount_component(maskedinput2, li2, null);\n\t\t\tappend(li2, t26);\n\t\t\tappend(li2, label5);\n\t\t\tappend(li2, input2);\n\t\t\tappend(li2, t28);\n\t\t\tappend(li2, pre2);\n\t\t\tappend(ul0, t30);\n\t\t\tappend(ul0, li3);\n\t\t\tappend(li3, label6);\n\t\t\tappend(li3, t32);\n\t\t\tmount_component(maskedinput3, li3, null);\n\t\t\tappend(li3, t33);\n\t\t\tappend(li3, label7);\n\t\t\tappend(li3, input3);\n\t\t\tappend(li3, t35);\n\t\t\tappend(li3, pre3);\n\t\t\tappend(pre3, code3);\n\t\t\tappend(ul0, t43);\n\t\t\tappend(ul0, li4);\n\t\t\tappend(li4, label8);\n\t\t\tappend(li4, t45);\n\t\t\tmount_component(maskedinput4, li4, null);\n\t\t\tappend(li4, t46);\n\t\t\tappend(li4, label9);\n\t\t\tappend(li4, input4);\n\t\t\tappend(li4, t48);\n\t\t\tappend(li4, pre4);\n\t\t\tappend(pre4, code4);\n\t\t\tappend(div2, t58);\n\t\t\tappend(div2, div1);\n\t\t\tappend(div1, h21);\n\t\t\tappend(div1, t60);\n\t\t\tappend(div1, hr1);\n\t\t\tappend(div1, t61);\n\t\t\tappend(div1, ul1);\n\t\t\tappend(ul1, li5);\n\t\t\tappend(li5, label10);\n\t\t\tappend(li5, t63);\n\t\t\tmount_component(formattedinput0, li5, null);\n\t\t\tappend(li5, t64);\n\t\t\tappend(li5, label11);\n\t\t\tappend(li5, input5);\n\t\t\tappend(li5, t66);\n\t\t\tappend(li5, pre5);\n\t\t\tappend(ul1, t68);\n\t\t\tappend(ul1, li6);\n\t\t\tappend(li6, label12);\n\t\t\tappend(li6, t70);\n\t\t\tmount_component(formattedinput1, li6, null);\n\t\t\tappend(li6, t71);\n\t\t\tappend(li6, label13);\n\t\t\tappend(li6, input6);\n\t\t\tappend(li6, t73);\n\t\t\tappend(li6, pre6);\n\t\t\tappend(ul1, t75);\n\t\t\tappend(ul1, li7);\n\t\t\tappend(li7, label14);\n\t\t\tappend(li7, t77);\n\t\t\tmount_component(formattedinput2, li7, null);\n\t\t\tappend(li7, t78);\n\t\t\tappend(li7, label15);\n\t\t\tappend(li7, input7);\n\t\t\tappend(li7, t80);\n\t\t\tappend(li7, pre7);\n\t\t\tappend(ul1, t82);\n\t\t\tappend(ul1, li8);\n\t\t\tappend(li8, label16);\n\t\t\tappend(li8, t84);\n\t\t\tmount_component(formattedinput3, li8, null);\n\t\t\tappend(li8, t85);\n\t\t\tappend(li8, label17);\n\t\t\tappend(li8, input8);\n\t\t\tappend(li8, t87);\n\t\t\tappend(li8, pre8);\n\t\t\tappend(ul1, t89);\n\t\t\tappend(ul1, li9);\n\t\t\tappend(li9, label18);\n\t\t\tappend(li9, t91);\n\t\t\tmount_component(formattedinput4, li9, null);\n\t\t\tappend(li9, t92);\n\t\t\tappend(li9, label19);\n\t\t\tappend(li9, input9);\n\t\t\tappend(li9, t94);\n\t\t\tappend(li9, pre9);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: noop,\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\ttransition_in(maskedinput0.$$.fragment, local);\n\t\t\ttransition_in(maskedinput1.$$.fragment, local);\n\t\t\ttransition_in(maskedinput2.$$.fragment, local);\n\t\t\ttransition_in(maskedinput3.$$.fragment, local);\n\t\t\ttransition_in(maskedinput4.$$.fragment, local);\n\t\t\ttransition_in(formattedinput0.$$.fragment, local);\n\t\t\ttransition_in(formattedinput1.$$.fragment, local);\n\t\t\ttransition_in(formattedinput2.$$.fragment, local);\n\t\t\ttransition_in(formattedinput3.$$.fragment, local);\n\t\t\ttransition_in(formattedinput4.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\ttransition_out(maskedinput0.$$.fragment, local);\n\t\t\ttransition_out(maskedinput1.$$.fragment, local);\n\t\t\ttransition_out(maskedinput2.$$.fragment, local);\n\t\t\ttransition_out(maskedinput3.$$.fragment, local);\n\t\t\ttransition_out(maskedinput4.$$.fragment, local);\n\t\t\ttransition_out(formattedinput0.$$.fragment, local);\n\t\t\ttransition_out(formattedinput1.$$.fragment, local);\n\t\t\ttransition_out(formattedinput2.$$.fragment, local);\n\t\t\ttransition_out(formattedinput3.$$.fragment, local);\n\t\t\ttransition_out(formattedinput4.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) detach(main);\n\t\t\tdestroy_component(maskedinput0);\n\t\t\tdestroy_component(maskedinput1);\n\t\t\tdestroy_component(maskedinput2);\n\t\t\tdestroy_component(maskedinput3);\n\t\t\tdestroy_component(maskedinput4);\n\t\t\tdestroy_component(formattedinput0);\n\t\t\tdestroy_component(formattedinput1);\n\t\t\tdestroy_component(formattedinput2);\n\t\t\tdestroy_component(formattedinput3);\n\t\t\tdestroy_component(formattedinput4);\n\t\t}\n\t};\n}\n\nclass App extends SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\tinit(this, options, null, App_svelte_create_fragment, safe_not_equal, {}, App_svelte_add_css);\n\t}\n}\n\n/* harmony default export */ const App_svelte = (App);\n;// CONCATENATED MODULE: ./src/main.js\n\n\nconst app = new App_svelte({\n    props: {\n        name: \'Svelte Masked Input\',\n    },\n    target: document.body,\n});\n\n/* harmony default export */ const main = ((/* unused pure expression or super */ null && (app)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCLEVBQUUsS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFBLE1BQStDOztHQUNqSCxNQUtLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pSTTs7QUFFL0IsZ0JBQWdCLFVBQUc7QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQsMkNBQWUsbURBQUcsSUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N2ZWx0ZS1tYXNrZWQtaW5wdXQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcz85OWI0Iiwid2VicGFjazovL3N2ZWx0ZS1tYXNrZWQtaW5wdXQvLi9zcmMvY29tcG9uZW50cy9NYXNrZWRJbnB1dC5zdmVsdGU/NDFmMiIsIndlYnBhY2s6Ly9zdmVsdGUtbWFza2VkLWlucHV0Ly4vc3JjL2NvbXBvbmVudHMvRm9ybWF0dGVkSW5wdXQuc3ZlbHRlPzI3MmUiLCJ3ZWJwYWNrOi8vc3ZlbHRlLW1hc2tlZC1pbnB1dC8uL3NyYy9BcHAuc3ZlbHRlPzViODYiLCJ3ZWJwYWNrOi8vc3ZlbHRlLW1hc2tlZC1pbnB1dC8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbm9vcCgpIHsgfVxuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yIChjb25zdCBrIGluIHNyYylcbiAgICAgICAgdGFyW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiB0YXI7XG59XG5mdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuICAgIGlmIChpc19oeWRyYXRpbmcpIHtcbiAgICAgICAgaW5pdF9oeWRyYXRlKHRhcmdldCk7XG4gICAgICAgIGlmICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCkgfHwgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudEVsZW1lbnQgIT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG4gICAgICAgIHdoaWxlICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG4gICAgICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zW2ldKVxuICAgICAgICAgICAgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5mdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzX3Byb3Aob2JqLCBrKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFyZ2V0W2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHRleHQoZGF0YSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cbmZ1bmN0aW9uIHNwYWNlKCkge1xuICAgIHJldHVybiB0ZXh0KCcgJyk7XG59XG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGV4dCgnJyk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCkge1xuICAgICAgICAgICAgbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAocHJvcCBpbiBub2RlKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG4gICAgaWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzTm9kZSwgY3JlYXRlTm9kZSwgZG9udFVwZGF0ZUxhc3RJbmRleCA9IGZhbHNlKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IHJlc3VsdE5vZGUgPSAoKCkgPT4ge1xuICAgICAgICAvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZSgpO1xuICAgIH0pKCk7XG4gICAgcmVzdWx0Tm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICByZXR1cm4gcmVzdWx0Tm9kZTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmUuZm9yRWFjaCh2ID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKSk7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSAnJyArIGRhdGE7XG4gICAgICAgIGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhU3RyKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB0ZXh0KGRhdGEpLCB0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuICAgICk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gZmluZF9jb21tZW50KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbigpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggKyAxKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG4gICAgY29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oY2xhaW1lZF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgIT09IGRhdGEpXG4gICAgICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCBidWJibGVzID0gZmFsc2UpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgZmFsc2UsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICB0aGlzLmUgPSBlbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcChodG1sKSB7XG4gICAgICAgIHRoaXMuZCgpO1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIHRoaXMuaSh0aGlzLmEpO1xuICAgIH1cbiAgICBkKCkge1xuICAgICAgICB0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuICAgIH1cbn1cbmNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBhY3RpdmVfZG9jcyA9IG5ldyBTZXQoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpO1xuICAgIGFjdGl2ZV9kb2NzLmFkZChkb2MpO1xuICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldCB8fCAoZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQgPSBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKS5zaGVldCk7XG4gICAgY29uc3QgY3VycmVudF9ydWxlcyA9IGRvYy5fX3N2ZWx0ZV9ydWxlcyB8fCAoZG9jLl9fc3ZlbHRlX3J1bGVzID0ge30pO1xuICAgIGlmICghY3VycmVudF9ydWxlc1tuYW1lXSkge1xuICAgICAgICBjdXJyZW50X3J1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhY3RpdmVfZG9jcy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXNoZWV0ID0gZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQ7XG4gICAgICAgICAgICBsZXQgaSA9IHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LmRlbGV0ZVJ1bGUoaSk7XG4gICAgICAgICAgICBkb2MuX19zdmVsdGVfcnVsZXMgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZV9kb2NzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuICAgICAgICAgICAgZmx1c2hpZHgrKztcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuICAgIGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG5jb25zdCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciA9IC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmZ1bmN0aW9uIHNwcmVhZChhcmdzLCBjbGFzc2VzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBlc2NhcGVkID0ge1xuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7J1xufTtcbmZ1bmN0aW9uIGVzY2FwZShodG1sKSB7XG4gICAgcmV0dXJuIFN0cmluZyhodG1sKS5yZXBsYWNlKC9bXCInJjw+XS9nLCBtYXRjaCA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBlc2NhcGUodmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZWFjaChpdGVtcywgZm4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG4gICAgJCRyZW5kZXI6ICgpID0+ICcnXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQuJCRyZW5kZXIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JylcbiAgICAgICAgICAgIG5hbWUgKz0gJyB0aGlzPXsuLi59JztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlc2ApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcbiAgICBjb25zb2xlLmxvZyhge0BkZWJ1Z30gJHtmaWxlID8gZmlsZSArICcgJyA6ICcnfSgke2xpbmV9OiR7Y29sdW1ufSlgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuICcnO1xufVxubGV0IG9uX2Rlc3Ryb3k7XG5mdW5jdGlvbiBjcmVhdGVfc3NyX2NvbXBvbmVudChmbikge1xuICAgIGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0ICQkID0ge1xuICAgICAgICAgICAgb25fZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gYCAke25hbWV9JHt2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYD0ke3R5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShlc2NhcGUodmFsdWUpKSA6IGBcIiR7dmFsdWV9XCJgfWB9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogbnVsbCxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjQ0LjMnIH0sIGRldGFpbCksIHRydWUpKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGVzY2FwZWQsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9wcm9wYWdhdGlvbiwgc3Vic2NyaWJlLCBzdmdfZWxlbWVudCwgdGV4dCwgdGljaywgdGltZV9yYW5nZXNfdG9fYXJyYXksIHRvX251bWJlciwgdG9nZ2xlX2NsYXNzLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCwgdHJ1c3RlZCwgdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCwgdXBkYXRlX2tleWVkX2VhY2gsIHVwZGF0ZV9zbG90LCB1cGRhdGVfc2xvdF9iYXNlLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB4bGlua19hdHRyIH07XG4iLCI8c2NyaXB0IGxhbmc9XCJ0eXBlc2NyaXB0XCI+XG4gICAgZXhwb3J0IGxldCBsZXR0ZXIgPSAnXyc7XG4gICAgZXhwb3J0IGxldCBudW1iZXIgPSAnWGREbU15WTknO1xuICAgIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXIgPSAnJztcbiAgICBleHBvcnQgbGV0IHZhbGlkRXhhbXBsZSA9ICcnO1xuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSAnJztcbiAgICBleHBvcnQgbGV0IGNoYXJzZXQ6IHN0cmluZyA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBwYXR0ZXJuID0gJyc7XG4gICAgZXhwb3J0IGxldCBwcmVmaXggPSAnJztcbiAgICBleHBvcnQgbGV0IHJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICBsZXQgcmF3VmFsdWUgPSAnJztcbiAgICBsZXQgaW5wdXRFbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGxldCBjdXJyZW50UGF0dGVybiA9IG51bGw7XG4gICAgbGV0IHJlbWFpbmluZ01hc2sgPSBwbGFjZWhvbGRlcjtcblxuICAgICQ6IHZhbHVlID0gY2hhcnNldCA/IHJhd1ZhbHVlLnJlcGxhY2UoL1xcVy9nLCAnJykgOiByYXdWYWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgJDogcHJlZml4ID0gKHByZWZpeCB8fCAnJyk7XG4gICAgJDogcmF3VmFsdWUgPSBwcmVmaXggJiYgIXJhd1ZhbHVlID8gJyAnIDogcmF3VmFsdWU7XG4gICAgJDogaGlkZGVuVmFsdWUgPSBwcmVmaXggJiYgcmF3VmFsdWUgPT09ICcgJyA/ICcnIDogcmF3VmFsdWU7XG4gICAgJDogcmVtYWluaW5nTWFzayA9IHByZWZpeCA/IHBsYWNlaG9sZGVyLnJlcGxhY2UocHJlZml4LCAnJykgOiBwbGFjZWhvbGRlcjtcbiAgICAkOiB1c2VkUGF0dGVybiA9IHJlcXVpcmVkIHx8IHZhbHVlID8gcGF0dGVybiA6IG51bGw7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY3Vyc29yUG9zQmVmb3JlID0gaW5wdXRFbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBsZXQgY3Vyc29yUG9zQWZ0ZXI7XG4gICAgICAgIHJhd1ZhbHVlID0gaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGNoYXJzZXQgPyByYXdWYWx1ZS5yZXBsYWNlKC9cXFcvZywgJycpIDogcmF3VmFsdWUucmVwbGFjZSgvW15cXGQuLV0vZywgJycpO1xuICAgICAgICBjdXJyZW50UGF0dGVybiA9IG51bGw7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjdXJzb3JQb3NBZnRlciA9IGlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgICB1cGRhdGVNYXNrKCk7XG4gICAgICAgIGN1cnJlbnRQYXR0ZXJuID0gdXNlZFBhdHRlcm47XG5cbiAgICAgICAgaWYgKGN1cnNvclBvc0FmdGVyIC0gY3Vyc29yUG9zQmVmb3JlID4gMSApIHtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydCA9IGN1cnNvclBvc0JlZm9yZTtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5zZWxlY3Rpb25FbmQgPSBjdXJzb3JQb3NCZWZvcmU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNYXNrKCk6IHZvaWQge1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSAnJztcblxuICAgICAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxEL2csICcnKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBwbGFjZWhvbGRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXNJbnQgPSAhTnVtYmVyLmlzTmFOKHBhcnNlSW50KHN0cmlwcGVkVmFsdWVbal0sIDEwKSk7XG4gICAgICAgICAgICBjb25zdCBpc0xldHRlciA9IHN0cmlwcGVkVmFsdWVbal0gPyBzdHJpcHBlZFZhbHVlW2pdLm1hdGNoKC9bQS1aXS9pKSA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlc051bWJlciA9IG51bWJlci5pbmRleE9mKHBsYWNlaG9sZGVyW2ldKSA+PSAwO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlc0xldHRlciA9IGxldHRlci5pbmRleE9mKHBsYWNlaG9sZGVyW2ldKSA+PSAwO1xuXG4gICAgICAgICAgICBpZiAoKG1hdGNoZXNOdW1iZXIgJiYgaXNJbnQpIHx8IChjaGFyc2V0ICYmIG1hdGNoZXNMZXR0ZXIgJiYgaXNMZXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgKz0gc3RyaXBwZWRWYWx1ZVtqKytdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAoIWNoYXJzZXQgJiYgIWlzSW50ICYmIG1hdGNoZXNOdW1iZXIpXG4gICAgICAgICAgICAgICAgfHwgKGNoYXJzZXQgJiYgKChtYXRjaGVzTGV0dGVyICYmICFpc0xldHRlcikgfHwgKG1hdGNoZXNOdW1iZXIgJiYgIWlzSW50KSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIENoYXJhY3RlcicpO1xuICAgICAgICAgICAgICAgIHJhd1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlICs9IHBsYWNlaG9sZGVyW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBicmVhayBpZiBubyBjaGFyYWN0ZXJzIGxlZnQgYW5kIHRoZSBwYXR0ZXJuIGlzIG5vbi1zcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKHN0cmlwcGVkVmFsdWVbal0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkRXhhbXBsZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWxpZGF0ZVByb2dyZXNzKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhd1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHJlbWFpbmluZ01hc2sgPSBwbGFjZWhvbGRlci5zdWJzdHJpbmcocmF3VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgY3VycmVudFBhdHRlcm4gPSB1c2VkUGF0dGVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb2dyZXNzKG5ld1ZhbHVlKSB7XG4gICAgICAgIGxldCB0ZXN0VmFsdWUgPSAnJztcbiAgICAgICAgY29uc3QgcGF0dGVyblJlZ0V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRvIG1vbnRoc1xuICAgICAgICBpZiAobmV3VmFsdWUubGVuZ3RoID09PSAxICYmIHBsYWNlaG9sZGVyLnRvVXBwZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDIpID09PSAnTU0nKSB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPiAxICYmIG5ld1ZhbHVlIDwgMTApIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGAwJHtuZXdWYWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVzdCB0aGUgdmFsdWUsIHJlbW92aW5nIHRoZSBsYXN0IGNoYXJhY3RlciwgdW50aWwgd2hhdCB5b3UgaGF2ZSBpcyBhIHN1Ym1hdGNoXG4gICAgICAgIGZvciAobGV0IGkgPSBuZXdWYWx1ZS5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0ZXN0VmFsdWUgPSBuZXdWYWx1ZSArIHZhbGlkRXhhbXBsZS5zdWJzdHJpbmcobmV3VmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm5SZWdFeC50ZXN0KHRlc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc3Vic3RyaW5nKDAsIG5ld1ZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIj5cbiAgICA6aW52YWxpZCB7XG4gICAgICAgIG91dGxpbmU6IDFweCBzb2xpZCByZWQ7XG4gICAgfVxuXG4gICAgLnNoZWxsIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsaW5lLWhlaWdodDogMTtcbiAgICB9XG5cbiAgICAuc2hlbGwgc3BhbiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIGxlZnQ6IDRweDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgICAgICBjb2xvcjogI2NjYztcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIHotaW5kZXg6IC0xO1xuICAgIH1cbiAgICAuc2hlbGwgc3BhbiBpIHtcbiAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICAgICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICBpbnB1dC5tYXNrZWQsXG4gICAgLnNoZWxsIHNwYW4ge1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIH1cbjwvc3R5bGU+XG48c3BhbiBjbGFzcz1cInNoZWxsXCI+XG5cdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt2YWx1ZS5sZW5ndGggPyAnJyA6IHByZWZpeH08aT57aGlkZGVuVmFsdWV9PC9pPntyZW1haW5pbmdNYXNrfTwvc3Bhbj5cblx0PGlucHV0XG4gICAgICAgIGJpbmQ6dGhpcz17aW5wdXRFbGVtZW50fVxuICAgICAgICBjbGFzcz1cIm1hc2tlZFwiXG4gICAgICAgIHBhdHRlcm49e2N1cnJlbnRQYXR0ZXJufVxuICAgICAgICB2YWx1ZT17cmF3VmFsdWV9XG4gICAgICAgIG9uOmtleXVwPXt1cGRhdGV9XG4gICAgICAgIG1heGxlbmd0aD17cGxhY2Vob2xkZXIubGVuZ3RofVxuICAgICAgICB7Li4uJCRyZXN0UHJvcHN9XG5cdC8+XG48L3NwYW4+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0eXBlc2NyaXB0XCI+XG4gICAgZXhwb3J0IGxldCBwbGFjZWhvbGRlciA9ICcnO1xuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSAnJztcbiAgICBleHBvcnQgbGV0IHBhdHRlcm4gPSAnJztcbiAgICBleHBvcnQgbGV0IGZvcm1hdCA9ICcnO1xuICAgIGV4cG9ydCBsZXQgcHJlZml4ID0gJyc7XG4gICAgZXhwb3J0IGxldCByZXF1aXJlZCA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgZm9ybWF0dGVyID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IGxvY2FsZSA9ICdlbi11cyc7XG4gICAgZXhwb3J0IGxldCBjdXJyZW5jeSA9ICdVU0QnO1xuICAgIGV4cG9ydCBsZXQgZm9ybWF0T3B0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgc3RyaW5nPiA9IG51bGw7XG5cbiAgICBsZXQgcmF3VmFsdWUgPSAnJztcbiAgICBsZXQgaW5wdXRFbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGxldCBjdXJyZW50UGF0dGVybiA9IG51bGw7XG4gICAgbGV0IHJlbWFpbmluZ01hc2sgPSBwbGFjZWhvbGRlcjtcbiAgICBsZXQgc2lnbmlmaWNhbnREaWdpdHMgPSAxO1xuICAgIGxldCBkZWNpbWFsUmVnRXhwOiBSZWdFeHAgPSBudWxsO1xuICAgIGxldCBkZWNpbWFsRW5kUmVnRXhwOiBSZWdFeHAgPSBudWxsO1xuICAgIGxldCBzZXBlcmF0b3JzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICBjb25zdCBsb2cxMCA9IE1hdGgubG9nKDEwKTtcblxuICAgIGZ1bmN0aW9uIGdldFNlcGVyYXRvcnMoXykge1xuICAgICAgICBjb25zdCBudW1iZXJXaXRoR3JvdXBBbmREZWNpbWFsU2VwYXJhdG9yID0gMTAwMC4xO1xuICAgICAgICByZXR1cm4gSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlKVxuICAgICAgICAgICAgLmZvcm1hdFRvUGFydHMobnVtYmVyV2l0aEdyb3VwQW5kRGVjaW1hbFNlcGFyYXRvcilcbiAgICAgICAgICAgIC5yZWR1Y2UoKGNvbGxlY3Rpb24sIHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnZGVjaW1hbCcgfHwgcGFydC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bcGFydC50eXBlXSA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgfVxuXG4gICAgJDogc2VwZXJhdG9ycyA9IGdldFNlcGVyYXRvcnMobG9jYWxlKTtcblxuICAgIGZ1bmN0aW9uIGdldFNpZ25pZmljYW50RGlnaXRDb3VudChuKSB7XG4gICAgICAgIG4gPSBNYXRoLmFicyhwYXJzZUZsb2F0KFN0cmluZyhuKS5yZXBsYWNlKHNlcGVyYXRvcnMuZGVjaW1hbCwgJycpKSk7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG4gIT09IDAgJiYgbiAlIDEwID09PSAwKSB7XG4gICAgICAgICAgICBuIC89IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cobikgLyBsb2cxMCkgKyAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uRGlnaXRzKG51bWJlcikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKG51bWJlcikuc3BsaXQoJy4nKVsxXT8ubGVuZ3RoXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVGcmFjdGlvbkRpZ2l0cyhudW1iZXIsIGRpZ2l0cykge1xuICAgICAgICBsZXQgW2ludCwgZGVjaW1hbF0gPSBgJHtudW1iZXJ9YC5zcGxpdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGAke2ludH0uJHtkZWNpbWFsLnN1YnN0cmluZygwLCBkaWdpdHMpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHMgPSB7XG4gICAgICAgIGN1cnJlbmN5KGlucHV0KTogc3RyaW5nIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBmb3JtYXRPcHRpb25zIHx8IHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAwLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBvcHRpb25zLm1heGltdW1GcmFjdGlvbkRpZ2l0cztcblxuICAgICAgICAgICAgaWYgKGdldEZyYWN0aW9uRGlnaXRzKGlucHV0KSA+PSBtYXhpbXVtRnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRydW5jYXRlRnJhY3Rpb25EaWdpdHMoaW5wdXQsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdEZ1bmN0aW9uID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbi5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeUludChpbnB1dCk6IHN0cmluZyB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRGdW5jdGlvbiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdE9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICAgICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uLmZvcm1hdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGludChpbnB1dCk6IHN0cmluZyB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRGdW5jdGlvbiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdE9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICAgICAgICAgICAgc3R5bGU6ICdkZWNpbWFsJyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb24uZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyKGlucHV0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGZvcm1hdE9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMyxcbiAgICAgICAgICAgICAgICBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHM6IHNpZ25pZmljYW50RGlnaXRzLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnZGVjaW1hbCcsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IG9wdGlvbnMubWF4aW11bUZyYWN0aW9uRGlnaXRzO1xuXG4gICAgICAgICAgICBpZiAoZ2V0RnJhY3Rpb25EaWdpdHMoaW5wdXQpID49IG1heGltdW1GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gdHJ1bmNhdGVGcmFjdGlvbkRpZ2l0cyhpbnB1dCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZm9ybWF0RnVuY3Rpb24gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uLmZvcm1hdChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBlcmNlbnQoaW5wdXQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRGdW5jdGlvbiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdE9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3BlcmNlbnQnLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbi5mb3JtYXQoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICBwZXJjZW50SW50KGlucHV0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0RnVuY3Rpb24gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBmb3JtYXRPcHRpb25zIHx8IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3BlcmNlbnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb24uZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbHMoY3VycmVudEZvcm1hdHRlcikge1xuICAgICAgICBjb25zdCBpc0RlY2ltYWwgPSBkZWNpbWFsRW5kUmVnRXhwLnRlc3QoaW5wdXRFbGVtZW50LnZhbHVlKTtcbiAgICAgICAgY29uc3QgaGFzRGVjaW1hbCA9IGRlY2ltYWxSZWdFeHAudGVzdChpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICBjb25zdCB1c2VkVmFsdWUgPSBpc0RlY2ltYWwgPyB2YWx1ZS5zbGljZSgwLCAtMSkgOiB2YWx1ZTtcbiAgICAgICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUZsb2F0KHVzZWRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGRpZ2l0cyA9IGludFZhbHVlID4gMFxuICAgICAgICAgICAgPyBnZXRTaWduaWZpY2FudERpZ2l0Q291bnQodmFsdWUpICsgMVxuICAgICAgICAgICAgOiBNYXRoLm1pbig0LCBoYXNEZWNpbWFsID8gdmFsdWUubGVuZ3RoIC0gMSA6IHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ01hc2sgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgIH1cblxuICAgICAgICByZW1haW5pbmdNYXNrID0gYCR7aXNEZWNpbWFsID8gJycgOiBzZXBlcmF0b3JzLmRlY2ltYWx9JHtwbGFjZWhvbGRlckRlY2ltYWx9YDtcbiAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSAhLzAkLy50ZXN0KHJhd1ZhbHVlKSA/IHVuZGVmaW5lZCA6IGRpZ2l0cztcblxuICAgICAgICBpZiAoaGFzRGVjaW1hbCAmJiAhaXNEZWNpbWFsKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFsTGVuZ3RoID0gcmF3VmFsdWUuc3BsaXQoc2VwZXJhdG9ycy5kZWNpbWFsKVsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdEZWNpbWFscyA9IHBsYWNlaG9sZGVyRGVjaW1hbExlbmd0aCAtIGRlY2ltYWxMZW5ndGg7XG5cbiAgICAgICAgICAgIHJlbWFpbmluZ01hc2sgPSBgJHtyZW1haW5pbmdEZWNpbWFscyA+IDAgPyBwbGFjZWhvbGRlckRlY2ltYWwuc2xpY2UoLTEgKiBkZWNpbWFsTGVuZ3RoKSA6ICcnfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7Y3VycmVudEZvcm1hdHRlcihpbnRWYWx1ZSl9JHtpc0RlY2ltYWwgPyBzZXBlcmF0b3JzLmRlY2ltYWwgOiAnJ31gO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gICAgICAgIGN1cnJlbmN5OiB7XG4gICAgICAgICAgICBmb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdERlY2ltYWxzKGZvcm1hdHMuY3VycmVuY3kpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46ICdcXFxcJFswLTldezEsM30oLFswLTldezN9KXswLH0nLFxuICAgICAgICAgICAgcHJlZml4OiAnJCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3VycmVuY3lJbnQ6IHtcbiAgICAgICAgICAgIGZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihwbGFjZWhvbGRlci5sZW5ndGggPD0gcmF3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ01hc2sgPSAnICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nTWFza0xlbmd0aCA9IHBsYWNlaG9sZGVyLmxlbmd0aCAtIHJhd1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyLnNsaWNlKC0xICogcmVtYWluaW5nTWFza0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRzLmN1cnJlbmN5SW50KGludFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAnXFxcXCRbMC05XXsxLDN9KCxbMC05XXszfSl7MCx9JyxcbiAgICAgICAgICAgIHByZWZpeDogJyQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIGludDoge1xuICAgICAgICAgICAgZm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGludFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHBsYWNlaG9sZGVyLmxlbmd0aCA8PSByYXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ01hc2tMZW5ndGggPSBwbGFjZWhvbGRlci5sZW5ndGggLSByYXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ01hc2sgPSBwbGFjZWhvbGRlci5zbGljZSgtMSAqIHJlbWFpbmluZ01hc2tMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0cy5pbnQoaW50VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46ICdbMC05XXsxLDN9KCxbMC05XXszfSkqXFxcXC5bMC05XScsXG5cbiAgICAgICAgfSxcblxuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0RGVjaW1hbHMoZm9ybWF0cy5udW1iZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46ICdbMC05XXsxLDN9KCxbMC05XXszfSkqKFxcXFwuWzAtOV0rKT8kJyxcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJjZW50SW50OiB7XG4gICAgICAgICAgICBmb3JtYXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocGxhY2Vob2xkZXIubGVuZ3RoIDw9IHJhd1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdNYXNrID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nTWFza0xlbmd0aCA9IHBsYWNlaG9sZGVyLmxlbmd0aCAtIHJhd1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nTWFzayA9IHBsYWNlaG9sZGVyLnNsaWNlKC0xICogcmVtYWluaW5nTWFza0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHMuaW50KGludFZhbHVlKX1gO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1ZmZpeDogJyUnLFxuICAgICAgICAgICAgcGF0dGVybjogJ1swLTldezEsfSklJyxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgdmFsdWUgPSByYXdWYWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgcmF3VmFsdWUgPSBwcmVmaXggJiYgIXJhd1ZhbHVlID8gJyAnIDogcmF3VmFsdWU7XG4gICAgcmVtYWluaW5nTWFzayA9IHByZWZpeCA/IHBsYWNlaG9sZGVyLnJlcGxhY2UocHJlZml4LCAnJykgOiBwbGFjZWhvbGRlcjtcbiAgICAkOiBmb3JtYXR0ZXIgfHw9IGZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAkOiBwcmVmaXggPSBmb3JtYXQgPyAoZm9ybWF0dGVyc1tmb3JtYXRdLnByZWZpeCB8fCAnJykgOiAocHJlZml4IHx8ICcnKTtcbiAgICAkOiBzdWZmaXggPSBmb3JtYXQgPyAoZm9ybWF0dGVyc1tmb3JtYXRdLnN1ZmZpeCB8fCAnJykgOiAoc3VmZml4IHx8ICcnKTtcbiAgICAkOiBoaWRkZW5WYWx1ZSA9IHByZWZpeCAmJiByYXdWYWx1ZSA9PT0gJyAnID8gJycgOiByYXdWYWx1ZTtcbiAgICAkOiBkZWNpbWFsRW5kUmVnRXhwID0gbmV3IFJlZ0V4cChgXFxcXCR7c2VwZXJhdG9ycy5kZWNpbWFsfSRgKTtcbiAgICAkOiBkZWNpbWFsUmVnRXhwID0gbmV3IFJlZ0V4cChgXFxcXCR7c2VwZXJhdG9ycy5kZWNpbWFsfWApO1xuICAgICQ6IHBsYWNlaG9sZGVyRGVjaW1hbCA9IHBsYWNlaG9sZGVyPy5zcGxpdChzZXBlcmF0b3JzLmRlY2ltYWwpWzFdO1xuICAgICQ6IHBsYWNlaG9sZGVyRGVjaW1hbExlbmd0aCA9IHBsYWNlaG9sZGVyRGVjaW1hbD8ubGVuZ3RoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBjdXJzb3JQb3NCZWZvcmUgPSBpbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBjdXJzb3JQb3NBZnRlcjtcblxuICAgICAgICB2YWx1ZSA9IGlucHV0RWxlbWVudC52YWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgICAgIGN1cnJlbnRQYXR0ZXJuID0gbnVsbDtcblxuICAgICAgICBjdXJzb3JQb3NBZnRlciA9IGlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgcmF3VmFsdWUgPSBmb3JtYXR0ZXJzW2Zvcm1hdF0uZm9ybWF0KCk7XG5cblxuICAgICAgICBjdXJyZW50UGF0dGVybiA9IHVzZWRQYXR0ZXJuO1xuXG4gICAgICAgIGlmIChjdXJzb3JQb3NBZnRlciAtIGN1cnNvclBvc0JlZm9yZSA+IDEgKSB7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgPSBjdXJzb3JQb3NCZWZvcmU7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuc2VsZWN0aW9uRW5kID0gY3Vyc29yUG9zQmVmb3JlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJDogdXNlZFBhdHRlcm4gPSByZXF1aXJlZCB8fCB2YWx1ZSA/IChmb3JtYXQgPyBwYXR0ZXJuIHx8IGZvcm1hdHRlcnNbZm9ybWF0XS5wYXR0ZXJuIDogcGF0dGVybikgOiBudWxsO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAgIDppbnZhbGlkIHtcbiAgICAgICAgb3V0bGluZTogMXB4IHNvbGlkIHJlZDtcbiAgICB9XG5cbiAgICAuc2hlbGwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgIH1cblxuICAgIC5zaGVsbCA+IHNwYW4ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogNTAlO1xuICAgICAgICBsZWZ0OiA0cHg7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgICAgICAgY29sb3I6ICNjY2M7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB6LWluZGV4OiAtMTtcbiAgICB9XG4gICAgLnNoZWxsIHNwYW4gaSB7XG4gICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICAgICAgY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgfVxuXG4gICAgaW5wdXQubWFza2VkLFxuICAgIC5zaGVsbCA+IHNwYW4ge1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIH1cblxuICAgIC5zdWZmaXgge1xuICAgICAgICBjb2xvcjogaW5pdGlhbDtcbiAgICB9XG48L3N0eWxlPlxuPHNwYW4gY2xhc3M9XCJzaGVsbFwiPlxuXHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj57dmFsdWUubGVuZ3RoID8gJycgOiBwcmVmaXh9PGk+e2hpZGRlblZhbHVlfTwvaT57cmVtYWluaW5nTWFza308c3BhbiBjbGFzcz1cInN1ZmZpeFwiPntzdWZmaXh9PC9zcGFuPjwvc3Bhbj5cblx0PGlucHV0XG4gICAgICAgIGJpbmQ6dGhpcz17aW5wdXRFbGVtZW50fVxuICAgICAgICBjbGFzcz1cIm1hc2tlZFwiXG4gICAgICAgIHBhdHRlcm49e2N1cnJlbnRQYXR0ZXJufVxuICAgICAgICBiaW5kOnZhbHVlPXtyYXdWYWx1ZX1cbiAgICAgICAgb246a2V5dXA9e3VwZGF0ZX1cbiAgICAgICAgey4uLiQkcmVzdFByb3BzfVxuXHQvPlxuPC9zcGFuPlxuIiwiPHNjcmlwdCBsYW5nPVwidHlwZXNjcmlwdFwiPlxuXHRpbXBvcnQgTWFza2VkSW5wdXQgZnJvbSAnLi9jb21wb25lbnRzL01hc2tlZElucHV0LnN2ZWx0ZSc7XG4gICAgaW1wb3J0IEZvcm1hdHRlZElucHV0IGZyb20gJy4vY29tcG9uZW50cy9Gb3JtYXR0ZWRJbnB1dC5zdmVsdGUnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuICAgICoge1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cblx0bWFpbiB7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdHBhZGRpbmc6IDFlbTtcblx0XHRtYXJnaW46IDAgYXV0bztcblx0fVxuXHRoMSB7XG5cdFx0Y29sb3I6ICNmZjNlMDA7XG5cdFx0Zm9udC1zaXplOiA0ZW07XG5cdFx0Zm9udC13ZWlnaHQ6IDkwMDtcblx0fVxuICAgIGgyIHtcbiAgICAgICAgZm9udC1zaXplOiAyLjVlbTtcbiAgICB9XG4gICAgaDEsaDIge1xuICAgICAgICBmb250LWZhbWlseTogJ0N1dGl2ZSBNb25vJywgbW9ub3NwYWNlO1xuICAgIH1cbiAgICA6Z2xvYmFsKGJvZHkgKikge1xuICAgICAgICBmb250LWZhbWlseTogJ0N1dGl2ZSBNb25vJywgbW9ub3NwYWNlICFpbXBvcnRhbnQ7XG4gICAgfVxuICAgIDpnbG9iYWwoYm9keSBwKSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xuICAgICAgICBmb250LWZhbWlseTogJ05vdG8gU2FucyBKUCcsIHNhbnMtc2VyaWYgIWltcG9ydGFudDtcbiAgICB9XG5cdEBtZWRpYSAobWluLXdpZHRoOiA2NDBweCkge1xuXHRcdG1haW4ge1xuXHRcdFx0bWF4LXdpZHRoOiBub25lO1xuXHRcdH1cblx0fVxuICAgIC5ncmlkIHtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7XG5cbiAgICAgICAgQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XG4gICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XG5cdCAgICB9XG4gICAgfVxuXG4gICAgbGkgPiBsYWJlbDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnTm90byBTZXJpZiBKUCcsIHNlcmlmICFpbXBvcnRhbnQ7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcbiAgICB9XG5cbiAgICAuaXRlbSB7XG4gICAgICAgIG1hcmdpbjogMnJlbTtcbiAgICB9XG5cbiAgICBpbWcge1xuICAgICAgICB3aWR0aDogNDAwcHg7XG4gICAgfVxuXG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cblxuICAgIDpnbG9iYWwoaW5wdXQpLCA6Z2xvYmFsKC5zaGVsbCBzcGFuKSB7XG4gICAgICAgIHBhZGRpbmc6IDAuMjVyZW07XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XG4gICAgfVxuXG4gICAgbGkge1xuICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xuICAgIH1cblxuICAgIHByZSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQ6IGJsYWNrO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIHBhZGRpbmc6IDFyZW07XG4gICAgICAgIGJvcmRlcjogNHB4IGluc2V0IHJlZDtcbiAgICB9XG5cbiAgICBpbnB1dDpjaGVja2VkICsgcHJlIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuXG4gICAgLnRvZ2dsZSB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkO1xuICAgICAgICBwYWRkaW5nOiAwLjI1cmVtO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xuICAgICAgICBmb250LXdlaWdodDogOTAwO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZWVlO1xuICAgICAgICB9XG5cbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogIzMzMztcbiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuPC9zdHlsZT5cblxuPG1haW4+XG4gICAgPGltZyBzcmM9XCIuL21hc2tlZC1pbnB1dC1sb2dvLnN2Z1wiIGFsdD1cImxvZ29cIiAvPlxuXHQ8aDE+U3ZlbHRlIE1hc2tlZCBJbnB1dDwvaDE+XG4gICAgPHA+Q3liZXJuZXRpY2FsbHkgRW5oYW5jZWQgSW5wdXRzIHdpdGggTWFza3MgZm9yIFN2ZWx0ZSBBcHBzPC9wPlxuICAgIDxkaXYgY2xhc3M9XCJncmlkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtXCI+XG4gICAgICAgICAgICA8aDI+TWFza2VkIElucHV0czwvaDI+XG4gICAgICAgICAgICA8aHI+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiY2MtZXhwXCI+Q3JlZGl0IENhcmQgRXhwaXJhdGlvbiBNb250aDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxNYXNrZWRJbnB1dCBpZD1cImNjLWV4cFwiIHR5cGU9XCJ0ZWxcIiBwbGFjZWhvbGRlcj1cIk1NL1lZXCIgcGF0dGVybj1cIigxWzAtMl18MFsxLTldKVxcL1xcZFxcZFwiIHZhbGlkRXhhbXBsZT1cIjExLzE4XCIgdGl0bGU9XCIyLWRpZ2l0IG1vbnRoIGFuZCAyLWRpZ2l0IHllYXIgZ3JlYXRlciB0aGFuIDAxLzE1XCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJjYy1leHAtbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cImNjLWV4cC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJjYy1leHBcIj5DcmVkaXQgQ2FyZCBFeHBpcmF0aW9uIE1vbnRoJmx0Oy9sYWJlbD5cbiZsdDtNYXNrZWRJbnB1dFxuICAgIGlkPVwiY2MtZXhwXCJcbiAgICBwYXR0ZXJuPVwiKDFbMC0yXXwwWzEtOV0pXFwvXFxkXFxkXCJcbiAgICBwbGFjZWhvbGRlcj1cIk1NL1lZXCJcbiAgICB0aXRsZT1cIjItZGlnaXQgbW9udGggYW5kIDItZGlnaXQgeWVhciBncmVhdGVyIHRoYW4gMDEvMTVcIlxuICAgIHR5cGU9XCJ0ZWxcIlxuICAgIHZhbGlkRXhhbXBsZT1cIjExLzE4XCJcbi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiemlwXCI+WmlwIENvZGU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8TWFza2VkSW5wdXQgaWQ9XCJ6aXBcIiB0eXBlPVwidGVsXCIgcGxhY2Vob2xkZXI9XCJYWFhYWFwiIHBhdHRlcm49XCJcXGR7NX1cIiB0aXRsZT1cIjUtZGlnaXQgemlwIGNvZGVcIiAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRvZ2dsZVwiIGZvcj1cInppcC1tYXJrdXBcIj5TaG93IE1hcmt1cDwvbGFiZWw+PGlucHV0IGlkPVwiemlwLW1hcmt1cFwiIHR5cGU9XCJjaGVja2JveFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPHByZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlPlxuJmx0O2xhYmVsIGZvcj1cInppcFwiPlppcCBDb2RlJmx0Oy9sYWJlbD5cbiZsdDtNYXNrZWRJbnB1dFxuICAgIGlkPVwiemlwXCJcbiAgICB0eXBlPVwidGVsXCJcbiAgICBwbGFjZWhvbGRlcj1cIlhYWFhYXCJcbiAgICBwYXR0ZXJuPVwiXFxkezV9XCJcbiAgICB0aXRsZT1cIjUtZGlnaXQgemlwIGNvZGVcIlxuLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPC9wcmU+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJjYS16aXBcIj5DYW5hZGlhbiBaaXAgQ29kZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxNYXNrZWRJbnB1dCBpZD1cImNhLXppcFwiIHBsYWNlaG9sZGVyPVwiWFhYIFhYWFwiIHBhdHRlcm49XCJcXHdcXGRcXHcgXFxkXFx3XFxkXCIgY2hhcnNldD1cIl9YXyBYX1hcIiB0aXRsZT1cIjYtY2hhcmFjdGVyIGFscGhhbnVtZXJpYyB6aXAgY29kZSBpbiB0aGUgZm9ybWF0IG9mIEExQSAxQTFcIiAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRvZ2dsZVwiIGZvcj1cImNhLXppcC1tYXJrdXBcIj5TaG93IE1hcmt1cDwvbGFiZWw+PGlucHV0IGlkPVwiY2EtemlwLW1hcmt1cFwiIHR5cGU9XCJjaGVja2JveFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPHByZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlPlxuJmx0O2xhYmVsIGZvcj1cImNhLXppcFwiPkNhbmFkaWFuIFppcCBDb2RlJmx0Oy9sYWJlbD5cbiZsdDtNYXNrZWRJbnB1dFxuICAgIGNoYXJzZXQ9XCJfWF8gWF9YXCJcbiAgICBpZD1cImNhLXppcFwiXG4gICAgcGF0dGVybj1cIlxcd1xcZFxcdyBcXGRcXHdcXGRcIlxuICAgIHBsYWNlaG9sZGVyPVwiWFhYIFhYWFwiXG4gICAgdGl0bGU9XCI2LWNoYXJhY3RlciBhbHBoYW51bWVyaWMgemlwIGNvZGUgaW4gdGhlIGZvcm1hdCBvZiBBMUEgMUExXCJcbi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwidGVsXCI+VGVsZXBob25lPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPE1hc2tlZElucHV0IGlkPVwidGVsXCIgcGxhY2Vob2xkZXI9XCIoWFhYKSBYWFgtWFhYWFwiIHBhdHRlcm49XCJcXChcXGR7M31cXCkgXFxkezN9XFwtXFxkezR9XCIgIHRpdGxlPVwiMTAtZGlnaXQgbnVtYmVyXCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJ0ZWwtbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cInRlbC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJ0ZWxcIj5UZWxlcGhvbmUmbHQ7L2xhYmVsPlxuJmx0O01hc2tlZElucHV0XG4gICAgaWQ9XCJ0ZWxcIlxuICAgIHBhdHRlcm49XCJcXChcXGR7M31cXCkgXFxkezN9XFwtXFxkezR9XCJcbiAgICBwbGFjZWhvbGRlcj1cIihYWFgpIFhYWC1YWFhYXCJcbiAgICB0aXRsZT1cIjEwLWRpZ2l0IG51bWJlclwiXG4vPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImNjXCI+Q3JlZGl0IENhcmQgTnVtYmVyPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPE1hc2tlZElucHV0IGlkPVwiY2NcIiBwbGFjZWhvbGRlcj1cIlhYWFggWFhYWCBYWFhYIFhYWFhcIiBwYXR0ZXJuPVwiXFxkezR9IFxcZHs0fSBcXGR7NH0gXFxkezR9XCIgdGl0bGU9XCIxNi1kaWdpdCBudW1iZXJcIiAvPlxuXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRvZ2dsZVwiIGZvcj1cImNjLW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJjYy1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJjY1wiPkNyZWRpdCBDYXJkIE51bWJlciZsdDsvbGFiZWw+XG4mbHQ7TWFza2VkSW5wdXRcbiAgICBpZD1cImNjXCJcbiAgICBwYXR0ZXJuPVwiXFxkezR9IFxcZHs0fSBcXGR7NH0gXFxkezR9XCJcbiAgICBwbGFjZWhvbGRlcj1cIlhYWFggWFhYWCBYWFhYIFhYWFhcIlxuICAgIHRpdGxlPVwiMTYtZGlnaXQgbnVtYmVyXCJcbi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbVwiPlxuICAgICAgICAgICAgPGgyPkZvcm1hdHRlZCBJbnB1dHM8L2gyPlxuICAgICAgICAgICAgPGhyPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cIm51bWJlclwiPk51bWJlcjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxGb3JtYXR0ZWRJbnB1dCBpZD1cIm51bWJlclwiIHBsYWNlaG9sZGVyPVwiMC4wMFwiIGZvcm1hdD1cIm51bWJlclwiIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlXCIgZm9yPVwibnVtYmVyLW1hcmt1cFwiPlNob3cgTWFya3VwPC9sYWJlbD48aW5wdXQgaWQ9XCJudW1iZXItbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwibnVtYmVyXCI+TnVtYmVyJmx0Oy9sYWJlbD5cbiZsdDtGb3JtYXR0ZWRJbnB1dCBpZD1cIm51bWJlclwiIHBsYWNlaG9sZGVyPVwiMC4wMFwiIGZvcm1hdD1cIm51bWJlclwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiaW50XCI+SW50PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPEZvcm1hdHRlZElucHV0IGlkPVwiaW50XCIgcGxhY2Vob2xkZXI9XCJYXCIgZm9ybWF0PVwiaW50XCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJpbnQtbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cImludC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJpbnRcIj5JbnQmbHQ7L2xhYmVsPlxuJmx0O0Zvcm1hdHRlZElucHV0IGlkPVwiaW50XCIgcGxhY2Vob2xkZXI9XCJYXCIgZm9ybWF0PVwiaW50XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPC9wcmU+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJjdXJyZW5jeVwiPkN1cnJlbmN5PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPEZvcm1hdHRlZElucHV0IGlkPVwiY3VycmVuY3lcIiBwbGFjZWhvbGRlcj1cIlguWFhcIiBmb3JtYXQ9XCJjdXJyZW5jeVwiIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlXCIgZm9yPVwiY3VycmVuY3ktbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cImN1cnJlbmN5LW1hcmt1cFwiIHR5cGU9XCJjaGVja2JveFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPHByZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlPlxuJmx0O2xhYmVsIGZvcj1cImN1cnJlbmN5XCI+Q3VycmVuY3kmbHQ7L2xhYmVsPlxuJmx0O0Zvcm1hdHRlZElucHV0IGlkPVwiY3VycmVuY3lcIiBwbGFjZWhvbGRlcj1cIlguWFhcIiBmb3JtYXQ9XCJjdXJyZW5jeVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiY3VycmVuY3lJbnRcIj5DdXJyZW5jeSBJbnQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkSW5wdXQgaWQ9XCJjdXJyZW5jeUludFwiIHBsYWNlaG9sZGVyPVwiWFwiIGZvcm1hdD1cImN1cnJlbmN5SW50XCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJjdXJyZW5jeS1pbnQtbWFya3VwXCI+U2hvdyBNYXJrdXA8L2xhYmVsPjxpbnB1dCBpZD1cImN1cnJlbmN5LWludC1tYXJrdXBcIiB0eXBlPVwiY2hlY2tib3hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y29kZT5cbiZsdDtsYWJlbCBmb3I9XCJjdXJyZW5jeUludFwiPkN1cnJlbmN5IEludCZsdDsvbGFiZWw+XG4mbHQ7Rm9ybWF0dGVkSW5wdXQgaWQ9XCJjdXJyZW5jeUludFwiIHBsYWNlaG9sZGVyPVwiWFwiIGZvcm1hdD1cImN1cnJlbmN5SW50XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPC9wcmU+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJjdXJyZW5jeUludFwiPlBlcmNlbnQgSW50PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPEZvcm1hdHRlZElucHV0IGlkPVwiY3VycmVuY3lJbnRcIiBwbGFjZWhvbGRlcj1cIlhcIiBmb3JtYXQ9XCJwZXJjZW50SW50XCIgLz5cblxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBmb3I9XCJwZXJjZW50LWludC1tYXJrdXBcIj5TaG93IE1hcmt1cDwvbGFiZWw+PGlucHV0IGlkPVwicGVyY2VudC1pbnQtbWFya3VwXCIgdHlwZT1cImNoZWNrYm94XCIvPlxuICAgICAgICAgICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+XG4mbHQ7bGFiZWwgZm9yPVwiY3VycmVuY3lJbnRcIj5QZXJjZW50IEludCZsdDsvbGFiZWw+XG4mbHQ7Rm9ybWF0dGVkSW5wdXQgaWQ9XCJjdXJyZW5jeUludFwiIHBsYWNlaG9sZGVyPVwiWFwiIGZvcm1hdD1cInBlcmNlbnRJbnRcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L21haW4+XG4iLCJpbXBvcnQgQXBwIGZyb20gJy4vQXBwLnN2ZWx0ZSc7XG5cbmNvbnN0IGFwcCA9IG5ldyBBcHAoe1xuICAgIHByb3BzOiB7XG4gICAgICAgIG5hbWU6ICdTdmVsdGUgTWFza2VkIElucHV0JyxcbiAgICB9LFxuICAgIHRhcmdldDogZG9jdW1lbnQuYm9keSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhcHA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///815\n')}},__webpack_exports__={};__webpack_modules__[815]()})();